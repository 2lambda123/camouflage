{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Camouflage HTTP/gRPC Mocking tool Demo Support What is Camouflage? Camouflage is a service virtualization tool inspired by namshi/mockserver . Camouflage works on a file based endpoint configuration system, which means it allows you to create a mock endpoint by simply creating a set of directories and a mock file, using which necessary responses are generated when you call the endpoint. Available Features \ud83d\udd25 File based mocking support for HTTP, HTTPS, HTTP2, gRPC, Thrift and websockets. \ud83d\udd25 \u26a1 Dynamic/realistic responses without having to write any code. \u26a1 \ud83e\udde9 Flexibility to partially or fully code your responses. \ud83e\udde9 \ud83c\udfaf Conditional responses based on request parameters. \ud83c\udfaf \ud83c\udf1f Inbuilt Caching - In memory and redis. \ud83c\udf1f \ud83e\uddee Ability to fetch and condition the response using external data. Currently supported data sources are CSV and postgres. \ud83e\uddee \u23f3 Delay Simulation. \u23f3 \ud83d\udd0d Inbuilt monitoring. \ud83d\udd0d \ud83e\uddba Inbuilt backup and restore mechanism. \ud83e\uddba \u23e9 Quick start with camouflage init and camouflage restore modules. \u23e9 \ud83c\udf8a Deployable on standalone VMs, Dockers and Kubernetes. \ud83c\udf8a \ud83d\udcc1 Comes with a file explorer UI that allows modification of mock files hosted remotely. \ud83d\udcc1 \u2705 Validation of requests and responses using your OpenApi schema's. \u2705","title":"Home"},{"location":"#support","text":"","title":"Support"},{"location":"#what-is-camouflage","text":"Camouflage is a service virtualization tool inspired by namshi/mockserver . Camouflage works on a file based endpoint configuration system, which means it allows you to create a mock endpoint by simply creating a set of directories and a mock file, using which necessary responses are generated when you call the endpoint.","title":"What is Camouflage?"},{"location":"#available-features","text":"\ud83d\udd25 File based mocking support for HTTP, HTTPS, HTTP2, gRPC, Thrift and websockets. \ud83d\udd25 \u26a1 Dynamic/realistic responses without having to write any code. \u26a1 \ud83e\udde9 Flexibility to partially or fully code your responses. \ud83e\udde9 \ud83c\udfaf Conditional responses based on request parameters. \ud83c\udfaf \ud83c\udf1f Inbuilt Caching - In memory and redis. \ud83c\udf1f \ud83e\uddee Ability to fetch and condition the response using external data. Currently supported data sources are CSV and postgres. \ud83e\uddee \u23f3 Delay Simulation. \u23f3 \ud83d\udd0d Inbuilt monitoring. \ud83d\udd0d \ud83e\uddba Inbuilt backup and restore mechanism. \ud83e\uddba \u23e9 Quick start with camouflage init and camouflage restore modules. \u23e9 \ud83c\udf8a Deployable on standalone VMs, Dockers and Kubernetes. \ud83c\udf8a \ud83d\udcc1 Comes with a file explorer UI that allows modification of mock files hosted remotely. \ud83d\udcc1 \u2705 Validation of requests and responses using your OpenApi schema's. \u2705","title":"Available Features"},{"location":"available-monitoring/","text":"Monitoring Monitoring might not be of paramount importance when you are running unit tests or functional automation tests, but if you plan to use Camouflage for performance testing purposes, you would definitely need some monitoring in place. Thanks to swagger-stats , Camouflage provides you two options. You can use the inbuilt UI provided by swagger-stats by navigating to http://localhost:8080/monitoring, which will lead you to following dashboard updating itself in real time Note If you are running more than one worker, the above UI would not provide you aggregated metrics. Data displayed will be worker specific data and at this point, we don't have a control on which worker's data will be displayed. Every time UI refreshes, the displayed data might belong to any of the running workers. To provide the aggregated metrics, Camouflage runs a separate monitoring server, which runs by default on port 5555. The URL http://localhost:5555/metrics acts as a scraping endpoint for your Prometheus server. Store this data in Prometheus and then use Grafana to generate your own visualizations. You can install a Prometheus DB and configure it to scrape from /metrics endpoint, and use that data to create charts for monitoring your application. Caution Disable monitoring by setting a negative value to config.monitoring.port in config.yaml. Sample Prometheus yml global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: \"camouflage\" static_configs: - targets: [\"localhost:5555\"] Note Update the target with your IP and port if running remotely or if you have specified a different port while starting Camouflage","title":"Monitoring"},{"location":"available-monitoring/#monitoring","text":"Monitoring might not be of paramount importance when you are running unit tests or functional automation tests, but if you plan to use Camouflage for performance testing purposes, you would definitely need some monitoring in place. Thanks to swagger-stats , Camouflage provides you two options. You can use the inbuilt UI provided by swagger-stats by navigating to http://localhost:8080/monitoring, which will lead you to following dashboard updating itself in real time Note If you are running more than one worker, the above UI would not provide you aggregated metrics. Data displayed will be worker specific data and at this point, we don't have a control on which worker's data will be displayed. Every time UI refreshes, the displayed data might belong to any of the running workers. To provide the aggregated metrics, Camouflage runs a separate monitoring server, which runs by default on port 5555. The URL http://localhost:5555/metrics acts as a scraping endpoint for your Prometheus server. Store this data in Prometheus and then use Grafana to generate your own visualizations. You can install a Prometheus DB and configure it to scrape from /metrics endpoint, and use that data to create charts for monitoring your application. Caution Disable monitoring by setting a negative value to config.monitoring.port in config.yaml. Sample Prometheus yml global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: \"camouflage\" static_configs: - targets: [\"localhost:5555\"] Note Update the target with your IP and port if running remotely or if you have specified a different port while starting Camouflage","title":"Monitoring"},{"location":"back-up-and-restore/","text":"Backup and Restore How does Camouflage Restore work? Camouflage has an inbuilt backup and restore mechanism to keep your mocks safe. To enable or disable backups, update backup.enable property in your config file. To define the schedule for backup, update backup.cron property with a valid cron schedule (Refer Crontab.guru , if you are not familiar with cron schedules ) In order to restore your previously backed up data, all you need is your config.yml file. Run the following command in your working directory. camouflage restore --config config.yml What to do if you don't have a config.yml? Run the init command first and then restore. camouflage init camouflage restore --config config.yml Camouflage backs up Http mocks directory , key and certificates and gRPC mocks and protos from your project.","title":"Backup and Restore"},{"location":"back-up-and-restore/#backup-and-restore","text":"","title":"Backup and Restore"},{"location":"back-up-and-restore/#how-does-camouflage-restore-work","text":"Camouflage has an inbuilt backup and restore mechanism to keep your mocks safe. To enable or disable backups, update backup.enable property in your config file. To define the schedule for backup, update backup.cron property with a valid cron schedule (Refer Crontab.guru , if you are not familiar with cron schedules ) In order to restore your previously backed up data, all you need is your config.yml file. Run the following command in your working directory. camouflage restore --config config.yml What to do if you don't have a config.yml? Run the init command first and then restore. camouflage init camouflage restore --config config.yml Camouflage backs up Http mocks directory , key and certificates and gRPC mocks and protos from your project.","title":"How does Camouflage Restore work?"},{"location":"camouflage-ui/","text":"Camouflage UI Camouflage also provides a file explorer UI allowing you to work with your mocks. Camouflage uses a standalone UI that can be downloaded as an npm package from camouflage-filemanager . It currently allows following actions: Create mock files/folders' structure View and edit mock files Delete mock files/folders Download files Cut or Copy files/folders New features will soon be added to the UI, such as: Uploading files Uploading folders as zip/tgz Renaming files/folders Integrated terminal Screenshots:","title":"Camouflage UI"},{"location":"camouflage-ui/#camouflage-ui","text":"Camouflage also provides a file explorer UI allowing you to work with your mocks. Camouflage uses a standalone UI that can be downloaded as an npm package from camouflage-filemanager . It currently allows following actions: Create mock files/folders' structure View and edit mock files Delete mock files/folders Download files Cut or Copy files/folders New features will soon be added to the UI, such as: Uploading files Uploading folders as zip/tgz Renaming files/folders Integrated terminal Screenshots:","title":"Camouflage UI"},{"location":"capture-helper/","text":"Capture Helper This section aims to explain what data can be extracted and used to generate a response using handlebars. It can be used as reference for any available helpers, even though examples primarily focus on capture helper. Most helpers were originally built for http(s)/http2 protocols. However, as of v0.7.2 release, they can be used with all available protocols, i.e. grpc and websockets, with some obvious exceptions such as file and code helpers. ( code helper will eventually be supported for all protocols) Using with HTTP(s)/HTTP2 As shown in example on Handlebars page, you can use capture to extract information from specific parts of the incoming requests by specifying a from argument. Accepted values are query , headers , path and body . Using query and headers you can specify the argument key , to capture it's corresponding value. Using path you can specify the argument regex , to define a regular expression which captures your desired value. Using body would require you to specify two arguments, i.e. using and selector , where using can have values jsonpath or regex , while selector would be the respective jsonpath or regular expression. Please refer to the examples on the Handlebars page. Using with Websockets The available/required keywords, while using capture helper with websockets are, using and selector . You have access to the request payload, upon which you can execute a regex or jsonpath extractor to fetch desired values. Example {{capture using='jsonpath' selector='$.lastName'}} Using with gRPC Similar to websockets, while using capture helper with gRPC, available/required arguments are using and selector . Example {{capture using='jsonpath' selector='$.lastName'}} For unary calls and server side streams, helpers have access to request payload as is. For unary calls and server side streams, helpers have access to metadata as well, which can be captured by specifying key and from . Example: {{capture from='metadata' key='metadata_key'}} For client side streaming calls, payloads from each stream are stored in an array, which is then made available to helpers. For bidi side streams, helpers can access the request payload as is during each streaming/ping-pong interaction i.e. while sending the \"data\" stream. Additionally, each payload is also stored in an array which is then made available to helpers while sending the \"end\" stream.","title":"Capture Helper"},{"location":"capture-helper/#capture-helper","text":"This section aims to explain what data can be extracted and used to generate a response using handlebars. It can be used as reference for any available helpers, even though examples primarily focus on capture helper. Most helpers were originally built for http(s)/http2 protocols. However, as of v0.7.2 release, they can be used with all available protocols, i.e. grpc and websockets, with some obvious exceptions such as file and code helpers. ( code helper will eventually be supported for all protocols)","title":"Capture Helper"},{"location":"capture-helper/#using-with-httpshttp2","text":"As shown in example on Handlebars page, you can use capture to extract information from specific parts of the incoming requests by specifying a from argument. Accepted values are query , headers , path and body . Using query and headers you can specify the argument key , to capture it's corresponding value. Using path you can specify the argument regex , to define a regular expression which captures your desired value. Using body would require you to specify two arguments, i.e. using and selector , where using can have values jsonpath or regex , while selector would be the respective jsonpath or regular expression. Please refer to the examples on the Handlebars page.","title":"Using with HTTP(s)/HTTP2"},{"location":"capture-helper/#using-with-websockets","text":"The available/required keywords, while using capture helper with websockets are, using and selector . You have access to the request payload, upon which you can execute a regex or jsonpath extractor to fetch desired values. Example {{capture using='jsonpath' selector='$.lastName'}}","title":"Using with Websockets"},{"location":"capture-helper/#using-with-grpc","text":"Similar to websockets, while using capture helper with gRPC, available/required arguments are using and selector . Example {{capture using='jsonpath' selector='$.lastName'}} For unary calls and server side streams, helpers have access to request payload as is. For unary calls and server side streams, helpers have access to metadata as well, which can be captured by specifying key and from . Example: {{capture from='metadata' key='metadata_key'}} For client side streaming calls, payloads from each stream are stored in an array, which is then made available to helpers. For bidi side streams, helpers can access the request payload as is during each streaming/ping-pong interaction i.e. while sending the \"data\" stream. Additionally, each payload is also stored in an array which is then made available to helpers while sending the \"end\" stream.","title":"Using with gRPC"},{"location":"configuring-cache/","text":"Configuring Cache In Memory Cache Camouflage uses apicache for caching. By default, apicache uses memory for caching, however it also provides a number of configurable options. To specify any of these optional configurations, modify config.yml in following way. cache: enable: false ttl_seconds: 300 cache_options: # Optional debug: false defaultDuration: \"1 hour\" enabled: true headerBlacklist: [] statusCodes: exclude: [] include: [] trackPerformance: false headers: {} respectCacheControl: false camouflage init , generates two options for cache configuration i.e. enable and ttl_seconds . These are parameters, Camouflage uses to configure a basic in memory cache. These options are not related or provided by apicache . However, you can additionally specify one or more options as shown above under cache_options , to control the behavior of Camouflage's cache mechanism. List of options made available by apicache are as follows: { debug: false|true, // if true, enables console output defaultDuration: '1 hour', // should be either a number (in ms) or a string, defaults to 1 hour enabled: true|false, // if false, turns off caching globally (useful on dev) headerBlacklist: [], // list of headers that should never be cached statusCodes: { exclude: [], // list status codes to specifically exclude (e.g. [404, 403] cache all responses unless they had a 404 or 403 status) include: [], // list status codes to require (e.g. [200] caches ONLY responses with a success/200 code) }, trackPerformance: false, // enable/disable performance tracking... WARNING: super cool feature, but may cause memory overhead issues headers: { // 'cache-control': 'no-cache' // example of header overwrite }, respectCacheControl: false|true // If true, 'Cache-Control: no-cache' in the request header will bypass the cache. } Redis Cache Cache can be implemented using redis, by providing an additional redis_options under cache_options cache: enable: false ttl_seconds: 300 cache_options: # Optional debug: false defaultDuration: \"1 hour\" enabled: true headerBlacklist: [] statusCodes: exclude: [] include: [] trackPerformance: false headers: {} respectCacheControl: false redis_options: # Optional host: 127.0.0.1 port: 6379 For a complete list of available redis options, refer to redis documentation Note Some of the options are not directly trasferred from the underlying packages. For example, apicache provides two more options, other than the ones mentioned above, i.e. redisClient and appendKey . Camouflage does not support appendKey , whereas redisClient is automatically configured when you provide redis_options as shown above. Similarily, redis package provides a retry_strategy option, which is not supported by Camouflage. This might change in future releases.","title":"Configuring Cache"},{"location":"configuring-cache/#configuring-cache","text":"","title":"Configuring Cache"},{"location":"configuring-cache/#in-memory-cache","text":"Camouflage uses apicache for caching. By default, apicache uses memory for caching, however it also provides a number of configurable options. To specify any of these optional configurations, modify config.yml in following way. cache: enable: false ttl_seconds: 300 cache_options: # Optional debug: false defaultDuration: \"1 hour\" enabled: true headerBlacklist: [] statusCodes: exclude: [] include: [] trackPerformance: false headers: {} respectCacheControl: false camouflage init , generates two options for cache configuration i.e. enable and ttl_seconds . These are parameters, Camouflage uses to configure a basic in memory cache. These options are not related or provided by apicache . However, you can additionally specify one or more options as shown above under cache_options , to control the behavior of Camouflage's cache mechanism. List of options made available by apicache are as follows: { debug: false|true, // if true, enables console output defaultDuration: '1 hour', // should be either a number (in ms) or a string, defaults to 1 hour enabled: true|false, // if false, turns off caching globally (useful on dev) headerBlacklist: [], // list of headers that should never be cached statusCodes: { exclude: [], // list status codes to specifically exclude (e.g. [404, 403] cache all responses unless they had a 404 or 403 status) include: [], // list status codes to require (e.g. [200] caches ONLY responses with a success/200 code) }, trackPerformance: false, // enable/disable performance tracking... WARNING: super cool feature, but may cause memory overhead issues headers: { // 'cache-control': 'no-cache' // example of header overwrite }, respectCacheControl: false|true // If true, 'Cache-Control: no-cache' in the request header will bypass the cache. }","title":"In Memory Cache"},{"location":"configuring-cache/#redis-cache","text":"Cache can be implemented using redis, by providing an additional redis_options under cache_options cache: enable: false ttl_seconds: 300 cache_options: # Optional debug: false defaultDuration: \"1 hour\" enabled: true headerBlacklist: [] statusCodes: exclude: [] include: [] trackPerformance: false headers: {} respectCacheControl: false redis_options: # Optional host: 127.0.0.1 port: 6379 For a complete list of available redis options, refer to redis documentation Note Some of the options are not directly trasferred from the underlying packages. For example, apicache provides two more options, other than the ones mentioned above, i.e. redisClient and appendKey . Camouflage does not support appendKey , whereas redisClient is automatically configured when you provide redis_options as shown above. Similarily, redis package provides a retry_strategy option, which is not supported by Camouflage. This might change in future releases.","title":"Redis Cache"},{"location":"contributing/","text":"Contributing Folder Structure . \u2514\u2500\u2500 bin \u2502 \u2514\u2500\u2500 camouflage.js \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 BackupScheduler \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 handlebar \u2502 \u2502 \u251c\u2500\u2500 handleBarDefinition.ts \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 logger \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 parser \u2502 \u2502 \u251c\u2500\u2500 GrpcParser.ts \u2502 \u2502 \u2514\u2500\u2500 HttpParser.ts \u2502 \u251c\u2500\u2500 protocols \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 routes \u2502 \u2502 \u251c\u2500\u2500 CamouflageController.ts \u2502 \u2502 \u2514\u2500\u2500 GlobalController.ts \u2502 \u2514\u2500\u2500 index.ts \u2514\u2500\u2500 ... Note Following section only tries to explain the tasks carried out by each module. Actual code level documentation is provided inline with each file for easier access. We also have a JSDocs available at here bin/camouflage.js This is the starting point of the application, which carries out following tasks: Takes in input from terminal/command line and config file. Defines actions for management modules such as camouflage init , camouflage restore and camouflage -h . Creates a cluster of master and worker processes. Decides if the passed arguments are valid and passes them on to the main app, else terminates the appliation with necessary error messages. src/index.ts Once application passes the first stage of checks, it will reach this file, which begins the actual mock server's tasks, namely: Define middlewares which are, express body parser, swagger stats, winston logger for express. Define static resource for two UIs. First, the documentation site hosted at root (/) location and second, file explorer UI hosted at /ui location. Override default values of required parameters. Register handlebars, management controllers and global generic controllers. Export start function to be used by bin/camouflage.js and express app object to be used by functional tests. src/BackupScheduler/index.ts This module simply creates a cron job which in turn copies mocks directories, certs directory and config file to the users' home directory as a backup procedure. The backup directory then can be used to restore the files to current working directory or a new project altogether. User can disable the backup feature if required via config file and can also control how often backups should be created by specifying a cron schedule src/handlebar/handleBarDefinition.ts This modules define the behavior of custom handlebars made available by Camouflage, such as random value helper, now helper, request helper and num between helpers to help users to prepare a response that mimics the real world response. src/handlebar/index.ts A master module for handlebar, simply to register all the helpers in one place. Alternative would be to register helpers in index.ts which is not ideal. src/logger/index.ts Module to define a logger according to the log level defined by config file, to be used throughout the application. src/parser/GrpcParser.ts GrpcParser is responsible for definition of generic functions which will respond to all calls from a gRPC client be it unary, bidi or one sided streams. These functions carry out following tasks: Determine the location appropriate mock files based on the handler specified by the incoming requests. Parse the contents of the mock files Replace templates with their values Add delays Create chunks in case of streams And finally send back the response. src/parser/HttpParser.ts HttpParser is responsible for definition of generic function to be used by GlobalController module. These functions carry out following tasks: Determine the location appropriate mock files based on the request URL path and method. Parse the contents of the mock files Replace templates with their values Add delays Add headers Add status codes Add response body And finally send back the response. src/protocols/index.ts This module creates servers with their listeners for http, https, http2 and gRPC protocols as specified by enabled properties for each protocols in config file. src/routes/CamouflageController.ts Camouflage controller is responsible for definition of endpoints useful for management modules. Available endpoints are: GET /mocks - Lists the available http and grpc mocks. Will be deprecated as the file explorer UI takes care of this internally, rendering this endpoint useless. DELETE /mocks - Deletes a mock with the specified path and method. Will be deprecated as the file explorer UI takes care of this internally, rendering this endpoint useless. GET /restart - Kills all the running workers which then automatically get replaced by their replacements since Camouflage follows 'restart unless explicitly stopped' policy for it's worker management. No UI component for this but will be developed soon. GET /ping - Shows the health and runtime of running worker src/routes/GlobalController.ts Global controller registers generic routes defined by (*) which will respond to all HTTP calls from a client unless explicitly handled by other modules from Camouflage. Uses getMatchedDir and getResponse function to locate appropriate mock file for an incoming HTTP/HTTPs/HTTP2 request and respond with the contents of the mockfile.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#folder-structure","text":". \u2514\u2500\u2500 bin \u2502 \u2514\u2500\u2500 camouflage.js \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 BackupScheduler \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 handlebar \u2502 \u2502 \u251c\u2500\u2500 handleBarDefinition.ts \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 logger \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 parser \u2502 \u2502 \u251c\u2500\u2500 GrpcParser.ts \u2502 \u2502 \u2514\u2500\u2500 HttpParser.ts \u2502 \u251c\u2500\u2500 protocols \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 routes \u2502 \u2502 \u251c\u2500\u2500 CamouflageController.ts \u2502 \u2502 \u2514\u2500\u2500 GlobalController.ts \u2502 \u2514\u2500\u2500 index.ts \u2514\u2500\u2500 ... Note Following section only tries to explain the tasks carried out by each module. Actual code level documentation is provided inline with each file for easier access. We also have a JSDocs available at here","title":"Folder Structure"},{"location":"contributing/#bincamouflagejs","text":"This is the starting point of the application, which carries out following tasks: Takes in input from terminal/command line and config file. Defines actions for management modules such as camouflage init , camouflage restore and camouflage -h . Creates a cluster of master and worker processes. Decides if the passed arguments are valid and passes them on to the main app, else terminates the appliation with necessary error messages.","title":"bin/camouflage.js"},{"location":"contributing/#srcindexts","text":"Once application passes the first stage of checks, it will reach this file, which begins the actual mock server's tasks, namely: Define middlewares which are, express body parser, swagger stats, winston logger for express. Define static resource for two UIs. First, the documentation site hosted at root (/) location and second, file explorer UI hosted at /ui location. Override default values of required parameters. Register handlebars, management controllers and global generic controllers. Export start function to be used by bin/camouflage.js and express app object to be used by functional tests.","title":"src/index.ts"},{"location":"contributing/#srcbackupschedulerindexts","text":"This module simply creates a cron job which in turn copies mocks directories, certs directory and config file to the users' home directory as a backup procedure. The backup directory then can be used to restore the files to current working directory or a new project altogether. User can disable the backup feature if required via config file and can also control how often backups should be created by specifying a cron schedule","title":"src/BackupScheduler/index.ts"},{"location":"contributing/#srchandlebarhandlebardefinitionts","text":"This modules define the behavior of custom handlebars made available by Camouflage, such as random value helper, now helper, request helper and num between helpers to help users to prepare a response that mimics the real world response.","title":"src/handlebar/handleBarDefinition.ts"},{"location":"contributing/#srchandlebarindexts","text":"A master module for handlebar, simply to register all the helpers in one place. Alternative would be to register helpers in index.ts which is not ideal.","title":"src/handlebar/index.ts"},{"location":"contributing/#srcloggerindexts","text":"Module to define a logger according to the log level defined by config file, to be used throughout the application.","title":"src/logger/index.ts"},{"location":"contributing/#srcparsergrpcparserts","text":"GrpcParser is responsible for definition of generic functions which will respond to all calls from a gRPC client be it unary, bidi or one sided streams. These functions carry out following tasks: Determine the location appropriate mock files based on the handler specified by the incoming requests. Parse the contents of the mock files Replace templates with their values Add delays Create chunks in case of streams And finally send back the response.","title":"src/parser/GrpcParser.ts"},{"location":"contributing/#srcparserhttpparserts","text":"HttpParser is responsible for definition of generic function to be used by GlobalController module. These functions carry out following tasks: Determine the location appropriate mock files based on the request URL path and method. Parse the contents of the mock files Replace templates with their values Add delays Add headers Add status codes Add response body And finally send back the response.","title":"src/parser/HttpParser.ts"},{"location":"contributing/#srcprotocolsindexts","text":"This module creates servers with their listeners for http, https, http2 and gRPC protocols as specified by enabled properties for each protocols in config file.","title":"src/protocols/index.ts"},{"location":"contributing/#srcroutescamouflagecontrollerts","text":"Camouflage controller is responsible for definition of endpoints useful for management modules. Available endpoints are: GET /mocks - Lists the available http and grpc mocks. Will be deprecated as the file explorer UI takes care of this internally, rendering this endpoint useless. DELETE /mocks - Deletes a mock with the specified path and method. Will be deprecated as the file explorer UI takes care of this internally, rendering this endpoint useless. GET /restart - Kills all the running workers which then automatically get replaced by their replacements since Camouflage follows 'restart unless explicitly stopped' policy for it's worker management. No UI component for this but will be developed soon. GET /ping - Shows the health and runtime of running worker","title":"src/routes/CamouflageController.ts"},{"location":"contributing/#srcroutesglobalcontrollerts","text":"Global controller registers generic routes defined by (*) which will respond to all HTTP calls from a client unless explicitly handled by other modules from Camouflage. Uses getMatchedDir and getResponse function to locate appropriate mock file for an incoming HTTP/HTTPs/HTTP2 request and respond with the contents of the mockfile.","title":"src/routes/GlobalController.ts"},{"location":"default-response/","text":"Default Response By default, Camouflage sends a default response for the APIs for which it cannot find a corresponding mock file. { \"error\": \"Not Found\" } However as a user you have the ability to override it at API level or at the global level. Consider the example below. If you make a GET call to /hello-world/greet/me , Camouflage will first evaluate the mock file location as ${MOCK_DIR}/hello-world/greet/me/GET.mock . If the above file is not found, Camouflage will look for a closest match. Let's say you don't have a folder ${MOCK_DIR}/hello-world/greet/me , but you have a folder ${MOCK_DIR}/hello-world/greet , closest match would be evaluated to ${MOCK_DIR}/hello-world/greet/__/GET.mock Similarly if you don't have a folder ${MOCK_DIR}/hello-world/greet/me , but you have a folder ${MOCK_DIR}/hello-world , closest match would be evaluated to ${MOCK_DIR}/hello-world/__/GET.mock In short, the closest match is ${MOCK_DIR} + last available folder + wildcard + ${HTTP_VERB}.mock . This is your API level default response. If none of the files are found as shown above, Camouflage will make one final attempt to find ${MOCK_DIR}/__/GET.mock . This is your global level default response. In case a global level default response too, is not found, Camouflage will fallback to it's inbuilt default response. To summarize, for a GET call to /hello-world/greet/me , Camouflage would search for corresponding mocks in following order: ${MOCK_DIR}/hello-world/greet/me/GET.mock - Exact Match ${MOCK_DIR}/hello-world/greet/__/GET.mock - API Level Default Response ${MOCK_DIR}/hello-world/__/GET.mock - API Level Default Response ${MOCK_DIR}/__/GET.mock - Global Default Response","title":"Default Response"},{"location":"default-response/#default-response","text":"By default, Camouflage sends a default response for the APIs for which it cannot find a corresponding mock file. { \"error\": \"Not Found\" } However as a user you have the ability to override it at API level or at the global level. Consider the example below. If you make a GET call to /hello-world/greet/me , Camouflage will first evaluate the mock file location as ${MOCK_DIR}/hello-world/greet/me/GET.mock . If the above file is not found, Camouflage will look for a closest match. Let's say you don't have a folder ${MOCK_DIR}/hello-world/greet/me , but you have a folder ${MOCK_DIR}/hello-world/greet , closest match would be evaluated to ${MOCK_DIR}/hello-world/greet/__/GET.mock Similarly if you don't have a folder ${MOCK_DIR}/hello-world/greet/me , but you have a folder ${MOCK_DIR}/hello-world , closest match would be evaluated to ${MOCK_DIR}/hello-world/__/GET.mock In short, the closest match is ${MOCK_DIR} + last available folder + wildcard + ${HTTP_VERB}.mock . This is your API level default response. If none of the files are found as shown above, Camouflage will make one final attempt to find ${MOCK_DIR}/__/GET.mock . This is your global level default response. In case a global level default response too, is not found, Camouflage will fallback to it's inbuilt default response. To summarize, for a GET call to /hello-world/greet/me , Camouflage would search for corresponding mocks in following order: ${MOCK_DIR}/hello-world/greet/me/GET.mock - Exact Match ${MOCK_DIR}/hello-world/greet/__/GET.mock - API Level Default Response ${MOCK_DIR}/hello-world/__/GET.mock - API Level Default Response ${MOCK_DIR}/__/GET.mock - Global Default Response","title":"Default Response"},{"location":"external-data-source/","text":"External Data Source Camouflage lets you condition your response for a specific set of data. Because we understand that random values don't always fulfill the requirements. Camouflage provides two helpers, pg and csv , which can be used to connect to a postgres db and csv data file respectively. Caution Both pg and csv helpers, rely on code injection for response generation. To use these helpers, the property injection needs to be set to true in config.yml. Injection can lead to security related issues and should be used judiciously. pg pg helper requires a postgres connection. To establish this connection between Camouflage and a postgres database, add following parameters in the config.yml file ext_data_source: pg: host: localhost port: 5432 user: root password: password database: postgres Update the connection parameters with your database details. In your mock files, use pg helper to run queries and fetch corresponding data. A sample mock file would look similar to the following content: HTTP/1.1 200 OK Content-Type: application/json {{#pg query='SELECT * FROM emp WHERE id = \\'1\\''}} (()=> { let response = [] result.rows.forEach(row => { const adult = row.age > 18 ? 'adult' : 'minor' response.push({ user: row.name, adult: adult }) }) return { status: 201, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(response) }; })(); {{/pg}} Explanation pg helper, similar to code or csv helper, is written as an IIFE (Immediately Invoked Function Expression). As shown above, IIFE is written as (()=> { ... })(); The helper requires a mandatory parameter, query as a string. The pg block gets access to a result object which can be used to condition the response. More details on how to use the result object can be found on node-postgres API documentation IIFE should return the generated response as a json object which contains body as a string. Optionally the response object can contain a status code and headers. csv To use csv helper, you would need a data source, which is a csv file. A sample file can be found in the github repo. Usage: CSV helper can be invoked in following manner, with three parameters, i.e. src: The location of your csv file. key: The column name in which you would like Camouflage to search for a specific value value: The value you want to search Camouflage then gives you access to a result array, which you can use inside an IIFE. It's your responsibility to decide how you want to use the result array. For example, in the snippet shown below, we are simply using the 1st element of the array i.e. result[0] . But you could also write a for loop to iterate over the array and generate your response body. Please note that the value you return MUST be a json object which contains a body in a string format (required), you can optionally provide status and headers as well. HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json {{#csv src=\"./test.csv\" key=\"City\" value=\"Worcester\"}} (()=> { return { status: 201, headers: { 'Content-Type': 'application/json' }, body: `{ \"City\": \"${result[0].City}\", \"State\": \"${result[0].State}\", \"LatD\": ${result[0].LatD}, \"LonD\": ${result[0].LonD} }` }; })(); {{/csv}} Camouflage provides you another alternative, in case you don't want to search for a specific value, instead you just want to pick one row at random and tailor your response to that specific row. In that case you'd remove key and value from the snippet shown above, and simply put random=true instead. To get entire data pass all=true . !!!caution 1. Note that, though we are calling it a \"c\"sv, it's not really comma separated, Camouflage expects the values to be separated by a semicolon. i.e. ; 2. Keep in mind that if you use random=true, you don't get the `result` object as an array, you would get one single object. So in the example above, `result[0].City` will not work, you'd need to update it to simply `result.City`","title":"External Data Source"},{"location":"external-data-source/#external-data-source","text":"Camouflage lets you condition your response for a specific set of data. Because we understand that random values don't always fulfill the requirements. Camouflage provides two helpers, pg and csv , which can be used to connect to a postgres db and csv data file respectively. Caution Both pg and csv helpers, rely on code injection for response generation. To use these helpers, the property injection needs to be set to true in config.yml. Injection can lead to security related issues and should be used judiciously.","title":"External Data Source"},{"location":"external-data-source/#pg","text":"pg helper requires a postgres connection. To establish this connection between Camouflage and a postgres database, add following parameters in the config.yml file ext_data_source: pg: host: localhost port: 5432 user: root password: password database: postgres Update the connection parameters with your database details. In your mock files, use pg helper to run queries and fetch corresponding data. A sample mock file would look similar to the following content: HTTP/1.1 200 OK Content-Type: application/json {{#pg query='SELECT * FROM emp WHERE id = \\'1\\''}} (()=> { let response = [] result.rows.forEach(row => { const adult = row.age > 18 ? 'adult' : 'minor' response.push({ user: row.name, adult: adult }) }) return { status: 201, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(response) }; })(); {{/pg}}","title":"pg"},{"location":"external-data-source/#explanation","text":"pg helper, similar to code or csv helper, is written as an IIFE (Immediately Invoked Function Expression). As shown above, IIFE is written as (()=> { ... })(); The helper requires a mandatory parameter, query as a string. The pg block gets access to a result object which can be used to condition the response. More details on how to use the result object can be found on node-postgres API documentation IIFE should return the generated response as a json object which contains body as a string. Optionally the response object can contain a status code and headers.","title":"Explanation"},{"location":"external-data-source/#csv","text":"To use csv helper, you would need a data source, which is a csv file. A sample file can be found in the github repo. Usage: CSV helper can be invoked in following manner, with three parameters, i.e. src: The location of your csv file. key: The column name in which you would like Camouflage to search for a specific value value: The value you want to search Camouflage then gives you access to a result array, which you can use inside an IIFE. It's your responsibility to decide how you want to use the result array. For example, in the snippet shown below, we are simply using the 1st element of the array i.e. result[0] . But you could also write a for loop to iterate over the array and generate your response body. Please note that the value you return MUST be a json object which contains a body in a string format (required), you can optionally provide status and headers as well. HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json {{#csv src=\"./test.csv\" key=\"City\" value=\"Worcester\"}} (()=> { return { status: 201, headers: { 'Content-Type': 'application/json' }, body: `{ \"City\": \"${result[0].City}\", \"State\": \"${result[0].State}\", \"LatD\": ${result[0].LatD}, \"LonD\": ${result[0].LonD} }` }; })(); {{/csv}} Camouflage provides you another alternative, in case you don't want to search for a specific value, instead you just want to pick one row at random and tailor your response to that specific row. In that case you'd remove key and value from the snippet shown above, and simply put random=true instead. To get entire data pass all=true . !!!caution 1. Note that, though we are calling it a \"c\"sv, it's not really comma separated, Camouflage expects the values to be separated by a semicolon. i.e. ; 2. Keep in mind that if you use random=true, you don't get the `result` object as an array, you would get one single object. So in the example above, `result[0].City` will not work, you'd need to update it to simply `result.City`","title":"csv"},{"location":"external-helper/","text":"External Helpers Camouflage allows users to be able to inject custom helpers while starting the Camouflage server. To inject you'd need to update config.yml with an additional key and provide a JSON file containing the definition of your custom helper. Example: ext_helpers: \"./custom_handlebar.json\" The JSON in the file should be an array of JSON Objects containing two keys: name and logic . Example: [ { \"name\": \"is\", \"logic\":\"(()=>{ logger.info(JSON.stringify((context.hash))); if(context.hash.value1===context.hash.value2) {return context.fn(this);} else {return context.inverse(this);} })()\" } ] name , can be anything of your choosing. logic , has to be an IIFE (Immediately Invoked Function Expression), inside an arrow function. The function has access to request and logger objects. The logic should return a value in accordance with your expectations from the function. This loads a custom helper, is , which can be used in your mock files to compare to values. Use it as shown in example: HTTP/1.1 200 OK {{#is value1=request.query.name value2='Shubhendu'}} Response if true {{else}} Response if false {{/is}} Caution If you plan to use any external dependencies in your code, you'd need to install them globally on the server Camouflage is hosted on, using npm i -g package_name . Before starting Camouflage, run the following command: npm root -g Pass the output of this command to the next command. On Linux/macOS: export NODE_PATH=\"output_from_previous_command\" On Windows: set NODE_PATH=\"output_from_previous_command\"","title":"External Helpers"},{"location":"external-helper/#external-helpers","text":"Camouflage allows users to be able to inject custom helpers while starting the Camouflage server. To inject you'd need to update config.yml with an additional key and provide a JSON file containing the definition of your custom helper. Example: ext_helpers: \"./custom_handlebar.json\" The JSON in the file should be an array of JSON Objects containing two keys: name and logic . Example: [ { \"name\": \"is\", \"logic\":\"(()=>{ logger.info(JSON.stringify((context.hash))); if(context.hash.value1===context.hash.value2) {return context.fn(this);} else {return context.inverse(this);} })()\" } ] name , can be anything of your choosing. logic , has to be an IIFE (Immediately Invoked Function Expression), inside an arrow function. The function has access to request and logger objects. The logic should return a value in accordance with your expectations from the function. This loads a custom helper, is , which can be used in your mock files to compare to values. Use it as shown in example: HTTP/1.1 200 OK {{#is value1=request.query.name value2='Shubhendu'}} Response if true {{else}} Response if false {{/is}} Caution If you plan to use any external dependencies in your code, you'd need to install them globally on the server Camouflage is hosted on, using npm i -g package_name . Before starting Camouflage, run the following command: npm root -g Pass the output of this command to the next command. On Linux/macOS: export NODE_PATH=\"output_from_previous_command\" On Windows: set NODE_PATH=\"output_from_previous_command\"","title":"External Helpers"},{"location":"external-middleware/","text":"External Middlewares Camouflage allows you to configure additional middlewares supported by express. This requires injection to be enabled in config.yml , as well as a middleware.js file at the root of your Camouflage project. middleware.js is expected to include an IIFE which includes logic to configure the required middlewares. This IIFE has access to following variables: app logger allRoutes The variables can be accessed by using this , e.g. this.app , this.logger and this.allRoutes . Example (() => { this.logger.info(\"inside middleware\"); const actuator = require(\"express-actuator\"); app.use(actuator()); this.app.use(\"/api/v1\", this.allRoutes); })(); Caution If you are using middleware injection, you would be responsible for configuring the mock routes, therefore it is mandatory to include the code this.app.use(prefix, this.allRoutes) in your IIFE, where prefix can be a string e.g. \"/\" or \"/api/v1\" or any other desired prefix to your mock routes. This would be applicable for all mocks. If you plan to use any external dependencies in your code, you'd need to install them globally on the server Camouflage is hosted on, using npm i -g express-actuator . Before starting Camouflage, run the following command: npm root -g Pass the output of this command to the next command. On Linux/macOS: export NODE_PATH=\"output_from_previous_command\" On Windows: set NODE_PATH=\"output_from_previous_command\"","title":"External Middlewares"},{"location":"external-middleware/#external-middlewares","text":"Camouflage allows you to configure additional middlewares supported by express. This requires injection to be enabled in config.yml , as well as a middleware.js file at the root of your Camouflage project. middleware.js is expected to include an IIFE which includes logic to configure the required middlewares. This IIFE has access to following variables: app logger allRoutes The variables can be accessed by using this , e.g. this.app , this.logger and this.allRoutes .","title":"External Middlewares"},{"location":"external-middleware/#example","text":"(() => { this.logger.info(\"inside middleware\"); const actuator = require(\"express-actuator\"); app.use(actuator()); this.app.use(\"/api/v1\", this.allRoutes); })(); Caution If you are using middleware injection, you would be responsible for configuring the mock routes, therefore it is mandatory to include the code this.app.use(prefix, this.allRoutes) in your IIFE, where prefix can be a string e.g. \"/\" or \"/api/v1\" or any other desired prefix to your mock routes. This would be applicable for all mocks. If you plan to use any external dependencies in your code, you'd need to install them globally on the server Camouflage is hosted on, using npm i -g express-actuator . Before starting Camouflage, run the following command: npm root -g Pass the output of this command to the next command. On Linux/macOS: export NODE_PATH=\"output_from_previous_command\" On Windows: set NODE_PATH=\"output_from_previous_command\"","title":"Example"},{"location":"folder-structure/","text":"Folder Structure The way you organize your directories inside the ${MOCKS_DIR}, determine how your endpoints will be available. Following examples will help you understand the folder structure you need to maintain. Basic GET Request to /hello-world Create a directory ${MOCKS_DIR}/hello-world Create a GET.mock file inside it with your required raw html response POST Request to /users Create a directory ${MOCKS_DIR}/users Create a POST.mock file inside it with your required raw html response GET Request to /users/:userId Create a directory ${MOCKS_DIR}/users/__ (double underscore) Create a GET.mock file inside it with your required raw html response Similarly you can create PUT.mock, DELETE.mock etc in your intended path. For wildcard, use directory name as __ (double underscore) Note Unlike the original mockserver, request matching criteria are taken care of inside the .mock files instead of naming the files in a certain way. We intend to keep the file names simple and in the format ${HTTP_METHOD}.mock Caution Protocols http, https and http2, share the same mocks directory and folder structure, however folder structure and mocks directory for gRPC and websockets mocks are different. Please refer to the section Mocking gRPC if you are planning to create gRPC mocks. What data to put in .mock files Camouflage expects a raw HTTP Response to be placed in the .mock files. Please refer to this Wikipedia page, if you are not sure what the response looks like. Each mock file can have the HTTP Responses in following manner: One response per .mock file. Multiple responses in one .mock file with conditions defined to help Camouflage decide which response should be sent under what conditions. (Read Handlebars section for more) Multiple responses separated by Camouflage's delimiter i.e. \"====\" (four equals). Camouflage will pick one response at random and send it to the client. An example of this can be found here The data you want to put can be easily fetched using a curl command with -i -X flags in the following manner. Example: curl -i -X GET https://jsonplaceholder.typicode.com/users/1 > GET.mock Running this command, gives you a GET.mock file with following content. Modify it according to your requirement and place it in the location ${MOCKS_DIR}/users/__, and you have successfully mocked jsonplaceholder API. HTTP/1.1 200 OK date: Sat, 17 Apr 2021 05:21:51 GMT content-type: application/json; charset=utf-8 content-length: 509 set-cookie: __cfduid=ddf6b687a745fea6ab343400b5dfe9f141618636911; expires=Mon, 17-May-21 05:21:51 GMT; path=/; domain=.typicode.com; HttpOnly; SameSite=Lax x-powered-by: Express x-ratelimit-limit: 1000 x-ratelimit-remaining: 998 x-ratelimit-reset: 1612952731 vary: Origin, Accept-Encoding access-control-allow-credentials: true cache-control: max-age=43200 pragma: no-cache expires: -1 x-content-type-options: nosniff etag: W/\"1fd-+2Y3G3w049iSZtw5t1mzSnunngE\" via: 1.1 vegur cf-cache-status: HIT age: 14578 accept-ranges: bytes cf-request-id: 097fe04d2c000019d97db7d000000001 expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\" report-to: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report?s=%2FkpNonG0wnuykR5xxlGXKBUxm5DN%2BI1PpQ0ytmiw931XaIVBNqZMJLEr0%2F3kDTrOhbX%2FCCPZtI4iuU3V%2F07wO5uwqov0d4c12%2Fcdpiz7TIFqzGkr7DwUrzt40CLH\"}],\"max_age\":604800,\"group\":\"cf-nel\"} nel: {\"max_age\":604800,\"report_to\":\"cf-nel\"} server: cloudflare cf-ray: 6413365b7e9919d9-SIN alt-svc: h3-27=\":443\"; ma=86400, h3-28=\":443\"; ma=86400, h3-29=\":443\"; ma=86400 { \"id\": 1, \"name\": \"Leanne Graham\", \"username\": \"Bret\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"Romaguera-Crona\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } Another, easier, approach to create mocks is by installing the REST Client VS Code Extension and using it to fetch the required data for mocks. Launch VS Code and install \"REST Client\" Extension by Huachao Mao or simply open the link above. Create a .http file in your project to document your actual http endpoints and make the requests. Visit REST Client github repository for more details on usage Line Breaks in mock files Note Camouflage by default looks for the OS specific line breaks. For example, if you are on MacOS or Unix based systems, the default line break/new line is \\n , whereas on windows it's \\r\\n . This is known to cause issues if your development environment and testing environment are different for Camouflage. For example, if you have created your mock file on a windows machine and uploaded it to a Camouflage server running on linux, your mocks might not work as expected. Or in case your text editor's line break settings do not match your OS default line break, you might not get an expected response. Starting v0.5.1, Camouflage detects new lines used in the file irrespective of the OS default. However, if you face any issues where you are getting a blank response or any unexpected response, please create an issue attaching your log files. REMEMBER TO REMOVE SENSITIVE DATA, IF ANY, FROM YOUR LOGS.","title":"Folder Structure"},{"location":"folder-structure/#folder-structure","text":"The way you organize your directories inside the ${MOCKS_DIR}, determine how your endpoints will be available. Following examples will help you understand the folder structure you need to maintain.","title":"Folder Structure"},{"location":"folder-structure/#basic-get-request-to-hello-world","text":"Create a directory ${MOCKS_DIR}/hello-world Create a GET.mock file inside it with your required raw html response","title":"Basic GET Request to /hello-world"},{"location":"folder-structure/#post-request-to-users","text":"Create a directory ${MOCKS_DIR}/users Create a POST.mock file inside it with your required raw html response","title":"POST Request to /users"},{"location":"folder-structure/#get-request-to-usersuserid","text":"Create a directory ${MOCKS_DIR}/users/__ (double underscore) Create a GET.mock file inside it with your required raw html response Similarly you can create PUT.mock, DELETE.mock etc in your intended path. For wildcard, use directory name as __ (double underscore) Note Unlike the original mockserver, request matching criteria are taken care of inside the .mock files instead of naming the files in a certain way. We intend to keep the file names simple and in the format ${HTTP_METHOD}.mock Caution Protocols http, https and http2, share the same mocks directory and folder structure, however folder structure and mocks directory for gRPC and websockets mocks are different. Please refer to the section Mocking gRPC if you are planning to create gRPC mocks.","title":"GET Request to /users/:userId"},{"location":"folder-structure/#what-data-to-put-in-mock-files","text":"Camouflage expects a raw HTTP Response to be placed in the .mock files. Please refer to this Wikipedia page, if you are not sure what the response looks like. Each mock file can have the HTTP Responses in following manner: One response per .mock file. Multiple responses in one .mock file with conditions defined to help Camouflage decide which response should be sent under what conditions. (Read Handlebars section for more) Multiple responses separated by Camouflage's delimiter i.e. \"====\" (four equals). Camouflage will pick one response at random and send it to the client. An example of this can be found here The data you want to put can be easily fetched using a curl command with -i -X flags in the following manner. Example: curl -i -X GET https://jsonplaceholder.typicode.com/users/1 > GET.mock Running this command, gives you a GET.mock file with following content. Modify it according to your requirement and place it in the location ${MOCKS_DIR}/users/__, and you have successfully mocked jsonplaceholder API. HTTP/1.1 200 OK date: Sat, 17 Apr 2021 05:21:51 GMT content-type: application/json; charset=utf-8 content-length: 509 set-cookie: __cfduid=ddf6b687a745fea6ab343400b5dfe9f141618636911; expires=Mon, 17-May-21 05:21:51 GMT; path=/; domain=.typicode.com; HttpOnly; SameSite=Lax x-powered-by: Express x-ratelimit-limit: 1000 x-ratelimit-remaining: 998 x-ratelimit-reset: 1612952731 vary: Origin, Accept-Encoding access-control-allow-credentials: true cache-control: max-age=43200 pragma: no-cache expires: -1 x-content-type-options: nosniff etag: W/\"1fd-+2Y3G3w049iSZtw5t1mzSnunngE\" via: 1.1 vegur cf-cache-status: HIT age: 14578 accept-ranges: bytes cf-request-id: 097fe04d2c000019d97db7d000000001 expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\" report-to: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report?s=%2FkpNonG0wnuykR5xxlGXKBUxm5DN%2BI1PpQ0ytmiw931XaIVBNqZMJLEr0%2F3kDTrOhbX%2FCCPZtI4iuU3V%2F07wO5uwqov0d4c12%2Fcdpiz7TIFqzGkr7DwUrzt40CLH\"}],\"max_age\":604800,\"group\":\"cf-nel\"} nel: {\"max_age\":604800,\"report_to\":\"cf-nel\"} server: cloudflare cf-ray: 6413365b7e9919d9-SIN alt-svc: h3-27=\":443\"; ma=86400, h3-28=\":443\"; ma=86400, h3-29=\":443\"; ma=86400 { \"id\": 1, \"name\": \"Leanne Graham\", \"username\": \"Bret\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"Romaguera-Crona\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } Another, easier, approach to create mocks is by installing the REST Client VS Code Extension and using it to fetch the required data for mocks. Launch VS Code and install \"REST Client\" Extension by Huachao Mao or simply open the link above. Create a .http file in your project to document your actual http endpoints and make the requests. Visit REST Client github repository for more details on usage","title":"What data to put in .mock files"},{"location":"folder-structure/#line-breaks-in-mock-files","text":"Note Camouflage by default looks for the OS specific line breaks. For example, if you are on MacOS or Unix based systems, the default line break/new line is \\n , whereas on windows it's \\r\\n . This is known to cause issues if your development environment and testing environment are different for Camouflage. For example, if you have created your mock file on a windows machine and uploaded it to a Camouflage server running on linux, your mocks might not work as expected. Or in case your text editor's line break settings do not match your OS default line break, you might not get an expected response. Starting v0.5.1, Camouflage detects new lines used in the file irrespective of the OS default. However, if you face any issues where you are getting a blank response or any unexpected response, please create an issue attaching your log files. REMEMBER TO REMOVE SENSITIVE DATA, IF ANY, FROM YOUR LOGS.","title":"Line Breaks in mock files"},{"location":"getting-started/","text":"Getting Started Camouflage is an NPM package, therefore to install Camouflage, you'd need to install NodeJS (>v14) first, if you haven't already done so. Install Camouflage: npm install -g camouflage-server Run camouflage --version to validate the installation was successful. Create an empty directory anywhere in your machine and navigate to it in your terminal. For npm and yarn , execute command camouflage init , or use npx degit camouflagejs/init myproject irrespective of your pacakge manager, to initialize a Camouflage project. This creates a basic skeleton of the folders you'd need in order to get started. You can modify these folders as per your requirements. Start the Camouflage server by initializing it with a config.yml file: camouflage --config config.yml Configuration Options / Sample Config yml File loglevel: info cpus: 1 monitoring: port: 5555 ssl: cert: \"./certs/server.cert\" key: \"./certs/server.key\" root_cert: \"./certs/root.cert\" protocols: http: enable: true mocks_dir: \"./mocks\" port: 8080 https: enable: false port: 8443 http2: enable: false port: 8081 ws: enable: false mocks_dir: \"./ws_mocks\" port: 8082 grpc: enable: false host: localhost port: 4312 mocks_dir: \"./grpc/mocks\" protos_dir: \"./grpc/protos\" grpc_tls: false thrift: enable: false mocks_dir: \"./thrift/mocks\" services: - port: 9999 service: \"/opt/gen-nodejs/Calculator\" handlers: - add - substract - ping backup: enable: false cron: \"0 * * * *\" # Hourly Backup cache: enable: false ttl_seconds: 300 injection: enable: false origins: - http://localhost:3000 - http://localhost:3001 - http://localhost:5000 # ext_helpers: \"./custom_handlebar.json\" Create your first mock Camouflage follows the same convention as mockserver to create mocks. For example, You start by creating a directory ${MOCKS_DIR}/hello-world Create a file GET.mock under ${MOCKS_DIR}/hello-world Paste following content: HTTP/1.1 200 OK X-Custom-Header: Custom-Value Content-Type: application/json { \"greeting\": \"Hey! It works!\" } Navigate to http://localhost:8080/hello-world Building from source Camouflage is still in its early development and has a long way to go before it reaches v1.0.0. Which means there might be some bugs, missed use cases, incorrect implementations of some functionalities. This is to be expected. But, the good news is that we are constantly evolving. There might be times when latest changes have not gone to release yet, such changes exist in the develop branch, which is the most updated version of Camouflage. If you'd like to get your hands on the upcoming release of Camouflage at any point, you can build it from the source. However, since this source might contain changes that are not tested yet and are not ready for use, you might want to proceed with caution. Clone the repository: git clone https://github.com/testinggospels/camouflage.git Checkout develop branch: git checkout develop Install dependencies: npm install Build the project: npm run build At this point you can run Camouflage using: node bin/camouflage.js --config ./config.yml However if you'd like to install Camouflage globally, execute: npm pack Install by running command: npm install -g camouflage-server-0.0.0-development.tgz or npm install -g camouflage-server-0.0.0-development.zip","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Camouflage is an NPM package, therefore to install Camouflage, you'd need to install NodeJS (>v14) first, if you haven't already done so. Install Camouflage: npm install -g camouflage-server Run camouflage --version to validate the installation was successful. Create an empty directory anywhere in your machine and navigate to it in your terminal. For npm and yarn , execute command camouflage init , or use npx degit camouflagejs/init myproject irrespective of your pacakge manager, to initialize a Camouflage project. This creates a basic skeleton of the folders you'd need in order to get started. You can modify these folders as per your requirements. Start the Camouflage server by initializing it with a config.yml file: camouflage --config config.yml","title":"Getting Started"},{"location":"getting-started/#configuration-options-sample-config-yml-file","text":"loglevel: info cpus: 1 monitoring: port: 5555 ssl: cert: \"./certs/server.cert\" key: \"./certs/server.key\" root_cert: \"./certs/root.cert\" protocols: http: enable: true mocks_dir: \"./mocks\" port: 8080 https: enable: false port: 8443 http2: enable: false port: 8081 ws: enable: false mocks_dir: \"./ws_mocks\" port: 8082 grpc: enable: false host: localhost port: 4312 mocks_dir: \"./grpc/mocks\" protos_dir: \"./grpc/protos\" grpc_tls: false thrift: enable: false mocks_dir: \"./thrift/mocks\" services: - port: 9999 service: \"/opt/gen-nodejs/Calculator\" handlers: - add - substract - ping backup: enable: false cron: \"0 * * * *\" # Hourly Backup cache: enable: false ttl_seconds: 300 injection: enable: false origins: - http://localhost:3000 - http://localhost:3001 - http://localhost:5000 # ext_helpers: \"./custom_handlebar.json\"","title":"Configuration Options / Sample Config yml File"},{"location":"getting-started/#create-your-first-mock","text":"Camouflage follows the same convention as mockserver to create mocks. For example, You start by creating a directory ${MOCKS_DIR}/hello-world Create a file GET.mock under ${MOCKS_DIR}/hello-world Paste following content: HTTP/1.1 200 OK X-Custom-Header: Custom-Value Content-Type: application/json { \"greeting\": \"Hey! It works!\" } Navigate to http://localhost:8080/hello-world","title":"Create your first mock"},{"location":"getting-started/#building-from-source","text":"Camouflage is still in its early development and has a long way to go before it reaches v1.0.0. Which means there might be some bugs, missed use cases, incorrect implementations of some functionalities. This is to be expected. But, the good news is that we are constantly evolving. There might be times when latest changes have not gone to release yet, such changes exist in the develop branch, which is the most updated version of Camouflage. If you'd like to get your hands on the upcoming release of Camouflage at any point, you can build it from the source. However, since this source might contain changes that are not tested yet and are not ready for use, you might want to proceed with caution. Clone the repository: git clone https://github.com/testinggospels/camouflage.git Checkout develop branch: git checkout develop Install dependencies: npm install Build the project: npm run build At this point you can run Camouflage using: node bin/camouflage.js --config ./config.yml However if you'd like to install Camouflage globally, execute: npm pack Install by running command: npm install -g camouflage-server-0.0.0-development.tgz or npm install -g camouflage-server-0.0.0-development.zip","title":"Building from source"},{"location":"handlebars/","text":"Handlebars Handlebars help you add character to your response. Instead of sending a static response or writing some code to generate a dynamic response, you can now simply use handlebars and let Camouflage do the work for you. Note Though Camouflage does not provide any tools to help you create your mocks, there are numerous Handlerbar snippet extensions available in VS Code marketplace which should help speed up your mocks creation process. Custom Helpers randomValue Type: Custom Helper Usage: {{randomValue}} - Simply using randomValue will generate a 16 character alphanumeric string. ex: 9ZeBvHW5viiYuWRa . {{randomValue type='ALPHANUMERIC'}} - You can specify a type as well. Your choices are: 'ALPHANUMERIC', 'ALPHABETIC', 'NUMERIC' and 'UUID'. {{randomValue type='NUMERIC' length=10}} - Don't want a 16 character output? Use length to specify the length. {{randomValue type='ALPHABETIC' uppercase=true}} - Finally, specify uppercase as true to get a, well, uppercase string. now Type: Custom Helper Usage: {{now}} - Simply using now will give you date in format YYYY-MM-DD hh:mm:ss {{now format='MM/DD/YYYY'}} - Format not to your liking? Use any format you'd like as long as it is supported by momentjs. {{now format='epoch'}} - Time since epoch in milliseconds {{now format='unix'}} - Time since epoch in seconds {{now format='MM/DD/YYYY hh:mm:ss' offset='-10 days'}} - Use offset to specify the delta for your desired date from the current date. Units for specifying offset are Key Shorthand years y quarters q months M weeks w days d hours h minutes m seconds s milliseconds ms capture Type: Custom Helper Usage: {{capture from='query' key='firstName'}} - Pretty self-explanatory, but if your endpoint looks like /hello-world?firstName=John&lastName=Wick. And your response is {\"message\": \"Hello Wick, John\"}, you can make the response dynamic by formatting your response as { \"message\": \"Hello {{capture from='query' key='lastName'}}, {{capture from='query' key='firstName'}}\" } {{capture from='cookies' key='mycookie'}} - For cookies, you'd need to specify a key to capture a value. {{capture from='path' regex='\\/users\\/get\\/(.*)?'}} - For path, you'd need to specify a regex to capture a value. {{capture from='body' using='jsonpath' selector='$.lastName'}} - To capture values from the request body, your options are either using='regex' or using='jsonpath'. Selector will change accordingly. Note capture helper can be used for all the supported protocols, i.e. http/https/http2, grpc and websockets. However, it's behavior, and the data it can access, varies across protocols. Read more on Capture Helper page. num_between Type: Custom Helper Usage: {{num_between lower=500 upper=600}} : Generate a random number between two values. {{num_between lower=500 upper=600 lognormal=true}} : Generate random numbers on a bell curve centered between two values. Tip: you can add this value in your response header with a key Response-Delay , to simulate a latency in your API. Not providing lower/upper value or providing values where lower > upper would set delay to 0, i.e. won't have any effect. Check Response Delays page for a detailed example array Type: Custom Helper Usage: {{array source='Apple,Banana,Mango,Kiwi' delimiter=','}} : Generate an array from a source using given delimiter. file Type: Custom Helper Usage: {{file path='/location/of/the/image/or/text/or/any/file'}} : If you want to serve a file as a response, maybe an image, or text file, a pdf document, or any type of supported files, use file helper to do so. An example is shown below: HTTP/1.1 200 OK Content-Type: application/pdf {{file path=\"./docs/camouflage.png\"}} code Type: Custom Helper Usage: Camouflage's implementation of Handlebars is robust enough to handle most dynamic responses i.e. capturing data from request, generating random numbers, as shown in examples above. However, if your requirement still cannot be fulfilled by Camouflage's helpers, you can write a custom code in javascript to achieve the same results. Refer to the example mock and explanation below: HTTP/1.1 200 OK Content-Type: application/json {{#code}} (()=>{ function getRandomNumberInRange(min, max) { return Math.round(Math.random() * (max - min) + min); } const name = request.query.name; const phone = getRandomNumberInRange(1000000000, 9999999999) logger.info(phone); return { status: 201, headers: { 'X-Requested-By': name }, body: `{ \"greeting\": \"Hello ${name}\", \"phone\": ${phone} }` }; })(); {{/code}} HTTP/1.1 200 OK : We start by creating a GET.mock as usual (or any ${VERB}.mock as per your requirement), where the 1st line of your file denotes protocol, version, status code and status message. This can be overridden from the code, however it is mandatory, in order to maintain a generic structure of mock files. Next you will provide a set of static headers, which will not change irrespective of your code logic. If you expect the header value to be dynamic, you don't need to provide them here. An empty line to mark the start of the body. Lastly, the most important part of your mock file. In place of the body, you write your code inside the code helper block provided by Camouflage. There are some restrictions though, read further. Code helper block can be defined by using {{#code}}...{{/code}} . The code you write has to be encapsulated in an IIFE, i.e. Immediately Invoked Function Expression, which can be done by wrapping your code in (() => { //your code here })(); As you might have noticed, we have defined the IIFE as an arrow function, this too is mandatory, since this provides you access to request and logger objects without having to bind this to the code's context. If that sounds complicated, all you need to understand is that using an arrow function provides you access to request and logger objects. Rest is just vanilla javascript code. Define a function to generate random numbers, Fetch the name from a request query parameter: name . Execute the random number function and store the return value in a phone variable. Log the generated phone number. Now comes the most important part. Your IIFE should return a JSON object, containing 3 keys status : An integer value (Optional) headers : A JSON object with keys as header name and values as header values. (Optional if you don't have any dynamic headers) body : A string (Required.) In this example, we have provided a static status code of 200. We have one header X-Requested-By , whose value is dynamic and changes based on the value user provided in the name query parameter while calling the mock endpoint. Finally, we have a stringified JSON object as body, where we are using name and phone as dynamic values. Please note that the same response can be easily achieved by other helpers also, and you don't necessarily need to write a code. This example was just to show you how we can use the code helper. Which is to say that you should avoid writing code if you don't have to, however if you absolutely have to write a code, you have an option to do that. inject Type: Custom Helper Usage: Another use case for custom code could be when you don't want to write a code for the entire response generation, but there are some parts of your response that need a custom code. Using inject helper you can use Camouflage's helpers and your custom code both together. Implementation remains similar to code helper, refer to the example below. HTTP/1.1 200 OK Content-Type: application/json { \"phone\": {{#inject}}(()=>{ return Math.round(Math.random() * 10000000000); })();{{/inject}} } csv Type: Custom Helper Usage: CSV Helper allows you to provide a data source as an input along with two combinations of policies With a key and value: In this case the helper will return a response specific to a given key and value Random: In this case, helper will pick one row from the provided csv and formulate the response for the provided row For more details on how to use csv helper, refer to External Data Source page. is Type: Custom Helper Credits: danharper/Handlebars-Helpers Usage: is helper can be considered as an extension of if which allows you to evaluate conditions that are lacking in inbuilt helper. is can be used in following three ways: With one argument: is acts exactly like if {{#is x}} ... {{else}} ... {{/is}} With two arguments: is compares the two are equal (a non-strict, == comparison, so 5 == '5' is true) {{#is x y}} ... {{else}} ... {{/is}} With three arguments: the second argument becomes the comparator. {{#is x \"not\" y}} ... {{else}} ... {{/is}} {{#is 5 \">=\" 2}} ... {{else}} ... {{/is}} Accepted operators are: == (same as not providing a comparator) != not (alias for != ) === !== > >= < <= in (to check if a value exists in an array. ex: {{#is 'John' in (capture from='body' using='jsonpath' selector='$.names')}} ) proxy Type: Custom Helper Usage: Proxy Helper allows you to redirect your calls to an actual downstream selectively. You might want to redirect all calls to actual downstream or some calls based on some condition, i.e. if a specific header exists, or a query param is provided. Example mock file content: HTTP/1.1 200 OK x-additional-headers: somevalue {{#proxy}} { \"target\": \"http://target_host:3000/\" } {{/proxy}} For more details on how to use the proxy helper, refer to the Proxy page. concat Type: Custom Helper Usage: Concatenates multiple strings together, (static or dynamic), to form a single string. Example: {{concat 'Camouflage ' 'is ' 'easy!!'}} results in Camouflage is easy . assign Type: Custom Helper Usage: Assign helper can be used to assign a value to a variable, by specifying a name value pair. This can be useful specially when using capture helper using regex and jsonpath selectors. Since running a regex or jsonpath operation is an expensive task, assign helper can be used to capture a value once, store it in a variable and use throughout the mock file. Aesthetically, it also improves readability of the mock file which otherwise would contain long illegible regular expressions repeated throughout the mock file. Example: Using a complex combination of helpers, i.e. assign , concat , pg and capture , to create a mock that would fetch a response from postgres table for a given id passed as a query parameter. {{assign name='query' value=(concat \"SELECT * FROM emp WHERE id = '\" (capture from=\"query\" key=\"id\") \"'\") }} HTTP/1.1 200 OK Content-Type: application/json {{#pg query=query}} (()=> { let response = [] result.rows.forEach(row => { const adult = row.age > 18 ? 'adult' : 'minor' response.push({ user: row.name, adult: adult }) }) return JSON.stringify(response) })(); {{/pg}} assign can be simply used as {{assign name='variable_name' value='variable_value'}} to assign a value to a variable. concat joins multiple strings together as passed. i.e. {{concat 'Camouflage ' 'is ' 'easy!!'}} would result in Camouflage is easy . In the example above, we capture the value of id from the query parameter id in request. We concatenate it with other static strings to form a query SELECT * FROM emp WHERE id = '1' . We assign the resulting string to a variable query . We pass the variable to pg helper as a query to be executed for results against the request, http://localhost:8080/pg?id=1 . Note Variables created using assign helpers can be accessed using context.data.root.VARIABLE_NAME inside the helpers that support code injection (as listed below) Caution Some of the Camouflage helpers allow (sometimes require) you to write your Javascript code in order to use them. However it's not a great idea to allow such code injections due to security concerns it creates. Camouflage disabled injection by default however you can enable it in config.yml. Following helpers will not work if injection is disabled. code; inject; pg; csv; and Any external custom handlebars you might define yourself. Enable injection if you understand the potential risks. state Type: Custom Helper Usage: State helper gets the mocked state value using a key send within the cookie header. If no value is found it will use the default context within the block. For example: { \"has_pending_order\": {{#state key='has-pending-order'}}false{{/state}}, \"cart\": {{#state key='cart'}}[ {\"id\": 999, \"name\": \"default prod\"} ]{{/state}} } To set a value just send cookie with a specific prefix. const prefix = \"mocked-state\"; const key = \"has-pending-order\"; setCookie(`${prefix}-has-pending-order`, 'true'); setCookie(`${prefix}-cart`, '[{id: 1, name: \"prod1\"}, {id: 2, name: \"prod2\"}]'); Caution the limit of cookie values in most browsers is 4KB Usage in Cypress If you use Camouglage with Cypress you could add the following custom command to make life easier. /** * Custom cypress command to set a mocked state */ Cypress.Commands.add('setState', (key: string, value: unknown) => { cy.setCookie(`mocked-state-${key}`, typeof value === 'string' ? value : JSON.stringify(value)); }); Then in your tests cy.setState('has_pending_order', true); cy.setState('cart', [{id: 1, name: \"prod1\"}, {id: 2, name: \"prod2\"}]); Inbuilt Helpers Note A variety of helpers are made available by Handlebar.js. Following example just showcases how the inbuilt helpers can be used with Camouflage, more details and examples can be found just about anywhere on the internet. As far as inbuilt helpers are concerned, you can use any of them as long as it makes sense to you. Raw HTML Request: POST /users HTTP/1.1 Content-Type: application/json { \"firstName\": \"Robert\", \"lastName\": \"Downey\", \"nicknames\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } Expected Raw HTML Response: HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91\", \"data\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } To create this service in camouflage, create a directory users under your ${MOCKS_DIR}. i.e. ${MOCKS_DIR}/users Create a file POST.mock and add following content to the file HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: {{randomValue type='UUID'}}\", \"data\": [ {{#each request.body.nicknames}} {{#if @last}} { \"nickname\": \"{{this.nickname}}\" } {{else}} { \"nickname\": \"{{this.nickname}}\" }, {{/if}} {{/each}} ] } Explanation We replaced the static UUID f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91 with {{randomValue type='UUID'}} , so that this value updates on each request. We wrapped our JSONObject inside a data array with an each helper which iterates over nicknames array from request body. Finally we put an if condition to check if we are at the last element of the array, we shouldn't append a comma at the end of our JSONObject, in order to get a valid JSON. If we are at any other element in the array, we'll add a comma to JSONObject. Available inbuilt helpers are if , unless , each , with , lookup and log . More details are available at Handlebars Documentation","title":"Handlebars"},{"location":"handlebars/#handlebars","text":"Handlebars help you add character to your response. Instead of sending a static response or writing some code to generate a dynamic response, you can now simply use handlebars and let Camouflage do the work for you. Note Though Camouflage does not provide any tools to help you create your mocks, there are numerous Handlerbar snippet extensions available in VS Code marketplace which should help speed up your mocks creation process.","title":"Handlebars"},{"location":"handlebars/#custom-helpers","text":"","title":"Custom Helpers"},{"location":"handlebars/#randomvalue","text":"Type: Custom Helper Usage: {{randomValue}} - Simply using randomValue will generate a 16 character alphanumeric string. ex: 9ZeBvHW5viiYuWRa . {{randomValue type='ALPHANUMERIC'}} - You can specify a type as well. Your choices are: 'ALPHANUMERIC', 'ALPHABETIC', 'NUMERIC' and 'UUID'. {{randomValue type='NUMERIC' length=10}} - Don't want a 16 character output? Use length to specify the length. {{randomValue type='ALPHABETIC' uppercase=true}} - Finally, specify uppercase as true to get a, well, uppercase string.","title":"randomValue"},{"location":"handlebars/#now","text":"Type: Custom Helper Usage: {{now}} - Simply using now will give you date in format YYYY-MM-DD hh:mm:ss {{now format='MM/DD/YYYY'}} - Format not to your liking? Use any format you'd like as long as it is supported by momentjs. {{now format='epoch'}} - Time since epoch in milliseconds {{now format='unix'}} - Time since epoch in seconds {{now format='MM/DD/YYYY hh:mm:ss' offset='-10 days'}} - Use offset to specify the delta for your desired date from the current date. Units for specifying offset are Key Shorthand years y quarters q months M weeks w days d hours h minutes m seconds s milliseconds ms","title":"now"},{"location":"handlebars/#capture","text":"Type: Custom Helper Usage: {{capture from='query' key='firstName'}} - Pretty self-explanatory, but if your endpoint looks like /hello-world?firstName=John&lastName=Wick. And your response is {\"message\": \"Hello Wick, John\"}, you can make the response dynamic by formatting your response as { \"message\": \"Hello {{capture from='query' key='lastName'}}, {{capture from='query' key='firstName'}}\" } {{capture from='cookies' key='mycookie'}} - For cookies, you'd need to specify a key to capture a value. {{capture from='path' regex='\\/users\\/get\\/(.*)?'}} - For path, you'd need to specify a regex to capture a value. {{capture from='body' using='jsonpath' selector='$.lastName'}} - To capture values from the request body, your options are either using='regex' or using='jsonpath'. Selector will change accordingly. Note capture helper can be used for all the supported protocols, i.e. http/https/http2, grpc and websockets. However, it's behavior, and the data it can access, varies across protocols. Read more on Capture Helper page.","title":"capture"},{"location":"handlebars/#num_between","text":"Type: Custom Helper Usage: {{num_between lower=500 upper=600}} : Generate a random number between two values. {{num_between lower=500 upper=600 lognormal=true}} : Generate random numbers on a bell curve centered between two values. Tip: you can add this value in your response header with a key Response-Delay , to simulate a latency in your API. Not providing lower/upper value or providing values where lower > upper would set delay to 0, i.e. won't have any effect. Check Response Delays page for a detailed example","title":"num_between"},{"location":"handlebars/#array","text":"Type: Custom Helper Usage: {{array source='Apple,Banana,Mango,Kiwi' delimiter=','}} : Generate an array from a source using given delimiter.","title":"array"},{"location":"handlebars/#file","text":"Type: Custom Helper Usage: {{file path='/location/of/the/image/or/text/or/any/file'}} : If you want to serve a file as a response, maybe an image, or text file, a pdf document, or any type of supported files, use file helper to do so. An example is shown below: HTTP/1.1 200 OK Content-Type: application/pdf {{file path=\"./docs/camouflage.png\"}}","title":"file"},{"location":"handlebars/#code","text":"Type: Custom Helper Usage: Camouflage's implementation of Handlebars is robust enough to handle most dynamic responses i.e. capturing data from request, generating random numbers, as shown in examples above. However, if your requirement still cannot be fulfilled by Camouflage's helpers, you can write a custom code in javascript to achieve the same results. Refer to the example mock and explanation below: HTTP/1.1 200 OK Content-Type: application/json {{#code}} (()=>{ function getRandomNumberInRange(min, max) { return Math.round(Math.random() * (max - min) + min); } const name = request.query.name; const phone = getRandomNumberInRange(1000000000, 9999999999) logger.info(phone); return { status: 201, headers: { 'X-Requested-By': name }, body: `{ \"greeting\": \"Hello ${name}\", \"phone\": ${phone} }` }; })(); {{/code}} HTTP/1.1 200 OK : We start by creating a GET.mock as usual (or any ${VERB}.mock as per your requirement), where the 1st line of your file denotes protocol, version, status code and status message. This can be overridden from the code, however it is mandatory, in order to maintain a generic structure of mock files. Next you will provide a set of static headers, which will not change irrespective of your code logic. If you expect the header value to be dynamic, you don't need to provide them here. An empty line to mark the start of the body. Lastly, the most important part of your mock file. In place of the body, you write your code inside the code helper block provided by Camouflage. There are some restrictions though, read further. Code helper block can be defined by using {{#code}}...{{/code}} . The code you write has to be encapsulated in an IIFE, i.e. Immediately Invoked Function Expression, which can be done by wrapping your code in (() => { //your code here })(); As you might have noticed, we have defined the IIFE as an arrow function, this too is mandatory, since this provides you access to request and logger objects without having to bind this to the code's context. If that sounds complicated, all you need to understand is that using an arrow function provides you access to request and logger objects. Rest is just vanilla javascript code. Define a function to generate random numbers, Fetch the name from a request query parameter: name . Execute the random number function and store the return value in a phone variable. Log the generated phone number. Now comes the most important part. Your IIFE should return a JSON object, containing 3 keys status : An integer value (Optional) headers : A JSON object with keys as header name and values as header values. (Optional if you don't have any dynamic headers) body : A string (Required.) In this example, we have provided a static status code of 200. We have one header X-Requested-By , whose value is dynamic and changes based on the value user provided in the name query parameter while calling the mock endpoint. Finally, we have a stringified JSON object as body, where we are using name and phone as dynamic values. Please note that the same response can be easily achieved by other helpers also, and you don't necessarily need to write a code. This example was just to show you how we can use the code helper. Which is to say that you should avoid writing code if you don't have to, however if you absolutely have to write a code, you have an option to do that.","title":"code"},{"location":"handlebars/#inject","text":"Type: Custom Helper Usage: Another use case for custom code could be when you don't want to write a code for the entire response generation, but there are some parts of your response that need a custom code. Using inject helper you can use Camouflage's helpers and your custom code both together. Implementation remains similar to code helper, refer to the example below. HTTP/1.1 200 OK Content-Type: application/json { \"phone\": {{#inject}}(()=>{ return Math.round(Math.random() * 10000000000); })();{{/inject}} }","title":"inject"},{"location":"handlebars/#csv","text":"Type: Custom Helper Usage: CSV Helper allows you to provide a data source as an input along with two combinations of policies With a key and value: In this case the helper will return a response specific to a given key and value Random: In this case, helper will pick one row from the provided csv and formulate the response for the provided row For more details on how to use csv helper, refer to External Data Source page.","title":"csv"},{"location":"handlebars/#is","text":"Type: Custom Helper Credits: danharper/Handlebars-Helpers Usage: is helper can be considered as an extension of if which allows you to evaluate conditions that are lacking in inbuilt helper. is can be used in following three ways: With one argument: is acts exactly like if {{#is x}} ... {{else}} ... {{/is}} With two arguments: is compares the two are equal (a non-strict, == comparison, so 5 == '5' is true) {{#is x y}} ... {{else}} ... {{/is}} With three arguments: the second argument becomes the comparator. {{#is x \"not\" y}} ... {{else}} ... {{/is}} {{#is 5 \">=\" 2}} ... {{else}} ... {{/is}} Accepted operators are: == (same as not providing a comparator) != not (alias for != ) === !== > >= < <= in (to check if a value exists in an array. ex: {{#is 'John' in (capture from='body' using='jsonpath' selector='$.names')}} )","title":"is"},{"location":"handlebars/#proxy","text":"Type: Custom Helper Usage: Proxy Helper allows you to redirect your calls to an actual downstream selectively. You might want to redirect all calls to actual downstream or some calls based on some condition, i.e. if a specific header exists, or a query param is provided. Example mock file content: HTTP/1.1 200 OK x-additional-headers: somevalue {{#proxy}} { \"target\": \"http://target_host:3000/\" } {{/proxy}} For more details on how to use the proxy helper, refer to the Proxy page.","title":"proxy"},{"location":"handlebars/#concat","text":"Type: Custom Helper Usage: Concatenates multiple strings together, (static or dynamic), to form a single string. Example: {{concat 'Camouflage ' 'is ' 'easy!!'}} results in Camouflage is easy .","title":"concat"},{"location":"handlebars/#assign","text":"Type: Custom Helper Usage: Assign helper can be used to assign a value to a variable, by specifying a name value pair. This can be useful specially when using capture helper using regex and jsonpath selectors. Since running a regex or jsonpath operation is an expensive task, assign helper can be used to capture a value once, store it in a variable and use throughout the mock file. Aesthetically, it also improves readability of the mock file which otherwise would contain long illegible regular expressions repeated throughout the mock file. Example: Using a complex combination of helpers, i.e. assign , concat , pg and capture , to create a mock that would fetch a response from postgres table for a given id passed as a query parameter. {{assign name='query' value=(concat \"SELECT * FROM emp WHERE id = '\" (capture from=\"query\" key=\"id\") \"'\") }} HTTP/1.1 200 OK Content-Type: application/json {{#pg query=query}} (()=> { let response = [] result.rows.forEach(row => { const adult = row.age > 18 ? 'adult' : 'minor' response.push({ user: row.name, adult: adult }) }) return JSON.stringify(response) })(); {{/pg}} assign can be simply used as {{assign name='variable_name' value='variable_value'}} to assign a value to a variable. concat joins multiple strings together as passed. i.e. {{concat 'Camouflage ' 'is ' 'easy!!'}} would result in Camouflage is easy . In the example above, we capture the value of id from the query parameter id in request. We concatenate it with other static strings to form a query SELECT * FROM emp WHERE id = '1' . We assign the resulting string to a variable query . We pass the variable to pg helper as a query to be executed for results against the request, http://localhost:8080/pg?id=1 . Note Variables created using assign helpers can be accessed using context.data.root.VARIABLE_NAME inside the helpers that support code injection (as listed below) Caution Some of the Camouflage helpers allow (sometimes require) you to write your Javascript code in order to use them. However it's not a great idea to allow such code injections due to security concerns it creates. Camouflage disabled injection by default however you can enable it in config.yml. Following helpers will not work if injection is disabled. code; inject; pg; csv; and Any external custom handlebars you might define yourself. Enable injection if you understand the potential risks.","title":"assign"},{"location":"handlebars/#state","text":"Type: Custom Helper Usage: State helper gets the mocked state value using a key send within the cookie header. If no value is found it will use the default context within the block. For example: { \"has_pending_order\": {{#state key='has-pending-order'}}false{{/state}}, \"cart\": {{#state key='cart'}}[ {\"id\": 999, \"name\": \"default prod\"} ]{{/state}} } To set a value just send cookie with a specific prefix. const prefix = \"mocked-state\"; const key = \"has-pending-order\"; setCookie(`${prefix}-has-pending-order`, 'true'); setCookie(`${prefix}-cart`, '[{id: 1, name: \"prod1\"}, {id: 2, name: \"prod2\"}]'); Caution the limit of cookie values in most browsers is 4KB","title":"state"},{"location":"handlebars/#usage-in-cypress","text":"If you use Camouglage with Cypress you could add the following custom command to make life easier. /** * Custom cypress command to set a mocked state */ Cypress.Commands.add('setState', (key: string, value: unknown) => { cy.setCookie(`mocked-state-${key}`, typeof value === 'string' ? value : JSON.stringify(value)); }); Then in your tests cy.setState('has_pending_order', true); cy.setState('cart', [{id: 1, name: \"prod1\"}, {id: 2, name: \"prod2\"}]);","title":"Usage in Cypress"},{"location":"handlebars/#inbuilt-helpers","text":"Note A variety of helpers are made available by Handlebar.js. Following example just showcases how the inbuilt helpers can be used with Camouflage, more details and examples can be found just about anywhere on the internet. As far as inbuilt helpers are concerned, you can use any of them as long as it makes sense to you. Raw HTML Request: POST /users HTTP/1.1 Content-Type: application/json { \"firstName\": \"Robert\", \"lastName\": \"Downey\", \"nicknames\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } Expected Raw HTML Response: HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91\", \"data\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } To create this service in camouflage, create a directory users under your ${MOCKS_DIR}. i.e. ${MOCKS_DIR}/users Create a file POST.mock and add following content to the file HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: {{randomValue type='UUID'}}\", \"data\": [ {{#each request.body.nicknames}} {{#if @last}} { \"nickname\": \"{{this.nickname}}\" } {{else}} { \"nickname\": \"{{this.nickname}}\" }, {{/if}} {{/each}} ] } Explanation We replaced the static UUID f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91 with {{randomValue type='UUID'}} , so that this value updates on each request. We wrapped our JSONObject inside a data array with an each helper which iterates over nicknames array from request body. Finally we put an if condition to check if we are at the last element of the array, we shouldn't append a comma at the end of our JSONObject, in order to get a valid JSON. If we are at any other element in the array, we'll add a comma to JSONObject. Available inbuilt helpers are if , unless , each , with , lookup and log . More details are available at Handlebars Documentation","title":"Inbuilt Helpers"},{"location":"mocking-gRPC/","text":"Mocking gRPC Camouflage introduces mocking gRPC services. Creation of mocks remains similar to HTTP mocks with some minor changes. For starters, gRPC mocks should not be placed in the same mocks directory as HTTP mocks, instead they should have their own mocks and protos directories. Secondly, the folder structure inside grpc mocks directory will follow the convention: ./grpc/mocks/package_name/service_name/method_name.mock If your package name is in the format com.foo.bar.package , format your folder structure and mock file in following manner: ./grpc/mocks/com/foo/bar/package/service_name/method_name.mock Enabling TLS for gRPC gRPC service mock runs without TLS by default. TLS can be enabled by setting the grpc_tls configuration value to true . The server cert and key files will then be read from cert and key values in ssl configuration. You may also add root_cert path configuration value to ssl configuration to enable client authentication. If no root_cert value is defined client authentication is disabled. Creating a gRPC Mock - Unary Or Client Side Streaming To create a new grpc mock, you would need the .proto file for your gRPC service. ex. todo.proto Create two new directories ./grpc/mocks and ./grpc/protos (you can name them as you wish) Place your .proto file in ./grpc/protos directory. Now, all we need is a .mock file. But, creating folder structure for gRPC follows a slightly different approach compared to HTTP mocks, and could be a little complicated if you are not aware of Protofile syntax. In any case, you would need the following steps. Start by looking for a package name in your .proto file. Next you'd need the service name, and finally the method you need to mock. Create a new folder in ./grpc/mocks directory with the package name. e.g. ./grpc/mocks/todoPackage Create another folder in ./grpc/mocks/todoPackage directory with the service name. e.g. ./grpc/mocks/todoPackage/TodoService Finally create a .mock file in the directory ./grpc/mocks/todoPackage/TodoService with the method name. e.g ./grpc/mocks/todoPackage/TodoService/createTodo.mock Place your expected response in the mock file and you are done. You can use the handlebars as usual in your response, though some of handlebars were built specifically for http based protocols and might not work as expected. For example, you can not use code helper for gRPC. To extract some value from the gRPC request body, you can still use capture helper like you would extract information from http request body, but you don't need to specify from='body' key/value. You can always load your own handlebars to Camouflage (Check External Helpers section). { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } Note If your protofile is importing any other local protofile, Camouflage registers the services/methods in the imported protofile as part of the primary protofile. In this case you'd need to specify the absolute or relative path of the imported protofile in a .protoignore file placed at the root of your Camouflage project. For example, you have a protofile A. i.e. ./grpc/protos/protofileA.proto , which imports protofile B, i.e. ./grpc/protos/subdir/protofileB.proto . All necessary parsing and registrations will be done as part of loading protofile A, Camouflage does not need to load protofile B separately. However, this instruction needs to be passed to Camouflage by placing the path ./grpc/protos/subdir/protofileB.proto in a .protoignore placed at the root of your Camouflage project. If appropriate protoignore does not exist, Camouflage will show a warning in your logs as Not re-registering some_method. Already registered. Creating a gRPC Mock - Server Side Streaming In case you are creating a service with server side streaming, you can place a separator between each chunk of responses in following manner: { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } ==== { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } ==== { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } Note The separator Camouflage understands is '====', i.e. 4 equals. Creating a gRPC Mock - Bidi Streaming If you are creating a bidirectional streaming mock, your mock file would contain two different types of data. One, what to send when the client is streaming, defined by the key \"data\". Two, an optional key \"end\", in case you want the server to send something when the client ends the connection. If your requirement is to simply end the stream when client ends the stream, without sending any additional data, you can simply omit the \"end\" key from your mockfile. { \"data\": { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" }, \"end\": { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } } Caution Since BIDI streaming is slightly more complicated to simulate, current implementation of Camouflage only supports the ping-pong model of streaming, i.e. client can send multiple requests as a stream and server will respond to each request with one response as part of a stream. Finally when the client ends the stream, the server will also end the stream. As shown in the example above, the server can also send a response just before ending the stream, but this is optional. Adding delays in gRPC You can also add delays in your grpc mock services, by adding a delay key with the value in your mock file. { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } You don't need to modify your proto file to accommodate the additional key, since Camouflage will delete the \"delay\" key from the response before sending it to the client. Sending GRPC Error responses Camouflage provides an experimental support to send error responses starting v0.11.0 onwards, for unary and client side streaming calls. To send an error response, append a json error object with code and optional message to your mock content. { \"error\": { \"code\": 16, \"message\": \"User is unauthenticted.\" } } Sending GRPC response metadata Camouflage provides an experimental support to send metadata/trailers with responses starting v0.11.0 onwards, for unary and client side streaming calls. To send metadata, append a json metadata object with relevant keys and values to your mock content. { \"metadata\": { \"key1\": \"value1\", \"key2\": \"value2\" } } Caution Since the Camouflage gRPC server needs to register the new services, everytime you add a new protofile, you'd need to restart the Camouflage server. Good news is, you can do so easily by making a get request to /restart endpoint. Though the downtime is minimal (less than a second, we do not recommend restarting the server during a performance test. Note that restart is required only if you add a new protofile. If you have added a new mock file or updated an existing one, a restart is not required. Overriding proto-loader's default options Camouflage uses default options as specified by @grpc/proto-loader . You can however override the default values by creating a plconfig.js file at the root of your Camouflage project. The contents of the file should export a variable plconfig as follows: module.exports.plconfig = { keepCase: true, longs: String, enums: String, bytes: Array } Available options are as follows: Field name Valid values Description keepCase true or false Preserve field names. The default is to change them to camel case. longs String or Number The type to use to represent long values. Defaults to a Long object type. enums String The type to use to represent enum values. Defaults to the numeric value. bytes Array or String The type to use to represent bytes values. Defaults to Buffer . defaults true or false Set default values on output objects. Defaults to false . arrays true or false Set empty arrays for missing array values even if defaults is false Defaults to false . objects true or false Set empty objects for missing object values even if defaults is false Defaults to false . oneofs true or false Set virtual oneof properties to the present field's name. Defaults to false . json true or false Represent Infinity and NaN as strings in float fields, and automatically decode google.protobuf.Any values. Defaults to false includeDirs An array of strings A list of search paths for imported .proto files. includeProtos An array of strings A list of proto files to be loaded. If specified, Camouflage will only load the specified proto files and ignore other protofiles in config.protocols.grpc.protos_dir . Note Camouflage extends the configurations provided by Protoloader Options( @grpc/proto-loader ).","title":"Mocking gRPC"},{"location":"mocking-gRPC/#mocking-grpc","text":"Camouflage introduces mocking gRPC services. Creation of mocks remains similar to HTTP mocks with some minor changes. For starters, gRPC mocks should not be placed in the same mocks directory as HTTP mocks, instead they should have their own mocks and protos directories. Secondly, the folder structure inside grpc mocks directory will follow the convention: ./grpc/mocks/package_name/service_name/method_name.mock If your package name is in the format com.foo.bar.package , format your folder structure and mock file in following manner: ./grpc/mocks/com/foo/bar/package/service_name/method_name.mock","title":"Mocking gRPC"},{"location":"mocking-gRPC/#enabling-tls-for-grpc","text":"gRPC service mock runs without TLS by default. TLS can be enabled by setting the grpc_tls configuration value to true . The server cert and key files will then be read from cert and key values in ssl configuration. You may also add root_cert path configuration value to ssl configuration to enable client authentication. If no root_cert value is defined client authentication is disabled.","title":"Enabling TLS for gRPC"},{"location":"mocking-gRPC/#creating-a-grpc-mock-unary-or-client-side-streaming","text":"To create a new grpc mock, you would need the .proto file for your gRPC service. ex. todo.proto Create two new directories ./grpc/mocks and ./grpc/protos (you can name them as you wish) Place your .proto file in ./grpc/protos directory. Now, all we need is a .mock file. But, creating folder structure for gRPC follows a slightly different approach compared to HTTP mocks, and could be a little complicated if you are not aware of Protofile syntax. In any case, you would need the following steps. Start by looking for a package name in your .proto file. Next you'd need the service name, and finally the method you need to mock. Create a new folder in ./grpc/mocks directory with the package name. e.g. ./grpc/mocks/todoPackage Create another folder in ./grpc/mocks/todoPackage directory with the service name. e.g. ./grpc/mocks/todoPackage/TodoService Finally create a .mock file in the directory ./grpc/mocks/todoPackage/TodoService with the method name. e.g ./grpc/mocks/todoPackage/TodoService/createTodo.mock Place your expected response in the mock file and you are done. You can use the handlebars as usual in your response, though some of handlebars were built specifically for http based protocols and might not work as expected. For example, you can not use code helper for gRPC. To extract some value from the gRPC request body, you can still use capture helper like you would extract information from http request body, but you don't need to specify from='body' key/value. You can always load your own handlebars to Camouflage (Check External Helpers section). { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } Note If your protofile is importing any other local protofile, Camouflage registers the services/methods in the imported protofile as part of the primary protofile. In this case you'd need to specify the absolute or relative path of the imported protofile in a .protoignore file placed at the root of your Camouflage project. For example, you have a protofile A. i.e. ./grpc/protos/protofileA.proto , which imports protofile B, i.e. ./grpc/protos/subdir/protofileB.proto . All necessary parsing and registrations will be done as part of loading protofile A, Camouflage does not need to load protofile B separately. However, this instruction needs to be passed to Camouflage by placing the path ./grpc/protos/subdir/protofileB.proto in a .protoignore placed at the root of your Camouflage project. If appropriate protoignore does not exist, Camouflage will show a warning in your logs as Not re-registering some_method. Already registered.","title":"Creating a gRPC Mock - Unary Or Client Side Streaming"},{"location":"mocking-gRPC/#creating-a-grpc-mock-server-side-streaming","text":"In case you are creating a service with server side streaming, you can place a separator between each chunk of responses in following manner: { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } ==== { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } ==== { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } Note The separator Camouflage understands is '====', i.e. 4 equals.","title":"Creating a gRPC Mock - Server Side Streaming"},{"location":"mocking-gRPC/#creating-a-grpc-mock-bidi-streaming","text":"If you are creating a bidirectional streaming mock, your mock file would contain two different types of data. One, what to send when the client is streaming, defined by the key \"data\". Two, an optional key \"end\", in case you want the server to send something when the client ends the connection. If your requirement is to simply end the stream when client ends the stream, without sending any additional data, you can simply omit the \"end\" key from your mockfile. { \"data\": { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" }, \"end\": { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } } Caution Since BIDI streaming is slightly more complicated to simulate, current implementation of Camouflage only supports the ping-pong model of streaming, i.e. client can send multiple requests as a stream and server will respond to each request with one response as part of a stream. Finally when the client ends the stream, the server will also end the stream. As shown in the example above, the server can also send a response just before ending the stream, but this is optional.","title":"Creating a gRPC Mock - Bidi Streaming"},{"location":"mocking-gRPC/#adding-delays-in-grpc","text":"You can also add delays in your grpc mock services, by adding a delay key with the value in your mock file. { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } You don't need to modify your proto file to accommodate the additional key, since Camouflage will delete the \"delay\" key from the response before sending it to the client.","title":"Adding delays in gRPC"},{"location":"mocking-gRPC/#sending-grpc-error-responses","text":"Camouflage provides an experimental support to send error responses starting v0.11.0 onwards, for unary and client side streaming calls. To send an error response, append a json error object with code and optional message to your mock content. { \"error\": { \"code\": 16, \"message\": \"User is unauthenticted.\" } }","title":"Sending GRPC Error responses"},{"location":"mocking-gRPC/#sending-grpc-response-metadata","text":"Camouflage provides an experimental support to send metadata/trailers with responses starting v0.11.0 onwards, for unary and client side streaming calls. To send metadata, append a json metadata object with relevant keys and values to your mock content. { \"metadata\": { \"key1\": \"value1\", \"key2\": \"value2\" } } Caution Since the Camouflage gRPC server needs to register the new services, everytime you add a new protofile, you'd need to restart the Camouflage server. Good news is, you can do so easily by making a get request to /restart endpoint. Though the downtime is minimal (less than a second, we do not recommend restarting the server during a performance test. Note that restart is required only if you add a new protofile. If you have added a new mock file or updated an existing one, a restart is not required.","title":"Sending GRPC response metadata"},{"location":"mocking-gRPC/#overriding-proto-loaders-default-options","text":"Camouflage uses default options as specified by @grpc/proto-loader . You can however override the default values by creating a plconfig.js file at the root of your Camouflage project. The contents of the file should export a variable plconfig as follows: module.exports.plconfig = { keepCase: true, longs: String, enums: String, bytes: Array } Available options are as follows: Field name Valid values Description keepCase true or false Preserve field names. The default is to change them to camel case. longs String or Number The type to use to represent long values. Defaults to a Long object type. enums String The type to use to represent enum values. Defaults to the numeric value. bytes Array or String The type to use to represent bytes values. Defaults to Buffer . defaults true or false Set default values on output objects. Defaults to false . arrays true or false Set empty arrays for missing array values even if defaults is false Defaults to false . objects true or false Set empty objects for missing object values even if defaults is false Defaults to false . oneofs true or false Set virtual oneof properties to the present field's name. Defaults to false . json true or false Represent Infinity and NaN as strings in float fields, and automatically decode google.protobuf.Any values. Defaults to false includeDirs An array of strings A list of search paths for imported .proto files. includeProtos An array of strings A list of proto files to be loaded. If specified, Camouflage will only load the specified proto files and ignore other protofiles in config.protocols.grpc.protos_dir . Note Camouflage extends the configurations provided by Protoloader Options( @grpc/proto-loader ).","title":"Overriding proto-loader's default options"},{"location":"mocking-soap/","text":"Mocking SOAP Camouflage supports mocking for SOAP services. How to mock SOAP? Start by enabling soap protocol in the config file, provide the location of your ${SOAP_MOCKS} directory and optionally update the port. Also configure the WSDL schema containing the services you wish to mock and the path you want it to be available on. protocols: soap: enable: true mocks_dir: \"./soap/mocks\" port: 8100 services: - wsdl: ./soap/countryservice.wsdl path: /countryinfo The folder structure for ${SOAP_MOCKS} follows the stucture of the WSDL schema, where you create a series of folders under ${SOAP_MOCKS} e.g. ${SOAP_MOCKS}/CountryInfoService/CountryInfoServiceSoap12/CountriesUsingCurrency.mock. This will allow you to POST to your mocked SOAP server using the url http://localhost:8100/countryinfo <?xml version=\"1.0\" encoding=\"utf-8\"?> <soap12:Envelope xmlns:soap12=\"http://www.w3.org/2003/05/soap-envelope\"> <soap12:Body> <CountriesUsingCurrency xmlns=\"http://www.oorsprong.org/websamples.countryinfo\"> <sISOCurrencyCode>EU</sISOCurrencyCode> </CountriesUsingCurrency> </soap12:Body> </soap12:Envelope> Camouflage uses CountriesUsingCurrency.mock to respond to all incoming messages. The contents of this file is not XML, but rather a JSON format containting a body property, which converted to a SOAP response by the mock server. The mock file, as you'd expect, supports handlebars! So you can generate random numbers, put conditional blocks etc. The format of mock file would be as follows: { \"body\": [ { \"sISOCode\": \"NL\", \"sName\": \"The Netherlands\" }, { \"sISOCode\": \"{{randomValue type='ALPHABETIC' uppercase=true length=2}}\", \"sName\": \"{{randomValue type='ALPHABETIC' uppercase=true length=10}}\" }, { \"sISOCode\": \"BE\", \"sName\": \"Belgium\" } ] } It's also possible to delay responses by adding a delay. For example 10 seconds: { \"delay\": 10000, \"body\": \"{{randomValue type='ALPHABETIC' uppercase=true length=2}}\" } Example request Request curl -X POST \\ 'http://localhost:8100/countryinfo' \\ --header 'Accept: */*' \\ --header 'Content-Type: application/soap+xml; charset=utf-8' \\ --data-raw '<?xml version=\"1.0\" encoding=\"utf-8\"?> <soap12:Envelope xmlns:soap12=\"http://www.w3.org/2003/05/soap-envelope\"> <soap12:Body> <CountriesUsingCurrency xmlns=\"http://www.oorsprong.org/websamples.countryinfo\"> <sISOCurrencyCode>EU</sISOCurrencyCode> </CountriesUsingCurrency> </soap12:Body> </soap12:Envelope>' Response <?xml version=\"1.0\" encoding=\"utf-8\"?> <soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:tns=\"http://www.oorsprong.org/websamples.countryinfo\"> <soap:Body> <CountriesUsingCurrencyResponse> <sISOCode>NL</sISOCode> <sName>The Netherlands</sName> </CountriesUsingCurrencyResponse> <CountriesUsingCurrencyResponse> <sISOCode>TK</sISOCode> <sName>TCULNUKYLD</sName> </CountriesUsingCurrencyResponse> <CountriesUsingCurrencyResponse> <sISOCode>BE</sISOCode> <sName>Belgium</sName> </CountriesUsingCurrencyResponse> </soap:Body> </soap:Envelope>","title":"Mocking SOAP"},{"location":"mocking-soap/#mocking-soap","text":"Camouflage supports mocking for SOAP services.","title":"Mocking SOAP"},{"location":"mocking-soap/#how-to-mock-soap","text":"Start by enabling soap protocol in the config file, provide the location of your ${SOAP_MOCKS} directory and optionally update the port. Also configure the WSDL schema containing the services you wish to mock and the path you want it to be available on. protocols: soap: enable: true mocks_dir: \"./soap/mocks\" port: 8100 services: - wsdl: ./soap/countryservice.wsdl path: /countryinfo The folder structure for ${SOAP_MOCKS} follows the stucture of the WSDL schema, where you create a series of folders under ${SOAP_MOCKS} e.g. ${SOAP_MOCKS}/CountryInfoService/CountryInfoServiceSoap12/CountriesUsingCurrency.mock. This will allow you to POST to your mocked SOAP server using the url http://localhost:8100/countryinfo <?xml version=\"1.0\" encoding=\"utf-8\"?> <soap12:Envelope xmlns:soap12=\"http://www.w3.org/2003/05/soap-envelope\"> <soap12:Body> <CountriesUsingCurrency xmlns=\"http://www.oorsprong.org/websamples.countryinfo\"> <sISOCurrencyCode>EU</sISOCurrencyCode> </CountriesUsingCurrency> </soap12:Body> </soap12:Envelope> Camouflage uses CountriesUsingCurrency.mock to respond to all incoming messages. The contents of this file is not XML, but rather a JSON format containting a body property, which converted to a SOAP response by the mock server. The mock file, as you'd expect, supports handlebars! So you can generate random numbers, put conditional blocks etc. The format of mock file would be as follows: { \"body\": [ { \"sISOCode\": \"NL\", \"sName\": \"The Netherlands\" }, { \"sISOCode\": \"{{randomValue type='ALPHABETIC' uppercase=true length=2}}\", \"sName\": \"{{randomValue type='ALPHABETIC' uppercase=true length=10}}\" }, { \"sISOCode\": \"BE\", \"sName\": \"Belgium\" } ] } It's also possible to delay responses by adding a delay. For example 10 seconds: { \"delay\": 10000, \"body\": \"{{randomValue type='ALPHABETIC' uppercase=true length=2}}\" }","title":"How to mock SOAP?"},{"location":"mocking-soap/#example-request","text":"Request curl -X POST \\ 'http://localhost:8100/countryinfo' \\ --header 'Accept: */*' \\ --header 'Content-Type: application/soap+xml; charset=utf-8' \\ --data-raw '<?xml version=\"1.0\" encoding=\"utf-8\"?> <soap12:Envelope xmlns:soap12=\"http://www.w3.org/2003/05/soap-envelope\"> <soap12:Body> <CountriesUsingCurrency xmlns=\"http://www.oorsprong.org/websamples.countryinfo\"> <sISOCurrencyCode>EU</sISOCurrencyCode> </CountriesUsingCurrency> </soap12:Body> </soap12:Envelope>' Response <?xml version=\"1.0\" encoding=\"utf-8\"?> <soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:tns=\"http://www.oorsprong.org/websamples.countryinfo\"> <soap:Body> <CountriesUsingCurrencyResponse> <sISOCode>NL</sISOCode> <sName>The Netherlands</sName> </CountriesUsingCurrencyResponse> <CountriesUsingCurrencyResponse> <sISOCode>TK</sISOCode> <sName>TCULNUKYLD</sName> </CountriesUsingCurrencyResponse> <CountriesUsingCurrencyResponse> <sISOCode>BE</sISOCode> <sName>Belgium</sName> </CountriesUsingCurrencyResponse> </soap:Body> </soap:Envelope>","title":"Example request"},{"location":"mocking-thrift/","text":"Mocking Thrift","title":"Mocking Thrift"},{"location":"mocking-thrift/#mocking-thrift","text":"","title":"Mocking Thrift"},{"location":"mocking-websockets/","text":"Mocking Websockets Camouflage supports mocking for websockets via native WebSockets API. Note that at this time, custom websockets implementations such as via Socket.io are not supported. Note In following instructions ${WS_MOCKS} refers to the location of websockets' mocks directory as specified under config.ws.mocks_dir in config.yml How to mock websockets? Start by enabling ws protocol in the config file, provide the location of your ${WS_MOCKS} directory and optionally update the port. The folder structure for ${WS_MOCKS} resembles HTTP mocks, where you create a series of folders under ${WS_MOCKS} e.g. ${WS_MOCKS}/hello/world. This will allow you to connect to the websockets server using the url ws://localhost:8082/hello/world Under /hello/world, you would need to provide two mock files, connection.mock (optional) and message.mock . Camouflage uses connection.mock to send you a custom message when you first connect to the server. This is optional, not providing this file would simply log a warning message in the console. Camouflage uses message.mock to respond to all incoming messages. This too can be optional if you don't want the server to return any messages, but not providing this file would log an error message in the console. The mock file, as you'd expect, supports handlebars! So you can generate random numbers, put conditional blocks etc. The format of mock file would be as follows: { \"broadcast\": \"{{now}}\", \"emit\": \"{{randomValue type='UUID'}}\", \"self\": \"{{randomValue}}\", \"delay\": \"{{num_between lower=500 upper=600}}\" } The JSON can have one or more of these three keys: broadcast , emit or self broadcast: Camouflage will broadcast these messages, i.e. The value which {{now}} evaluates to, in the above example, will be sent to all the connected clients, including the client emitting the message. emit: Camouflage will emit these messages, i.e. The value {{randomValue type='UUID'}} evaluates to in above example, will be sent to all the connected clients, except the client emitting the message. self: Camouflage will only send these messages to the client who made the request, i.e. The value {{randomValue}} evaluates to in above example, will be sent only to the client who made the request. Finally, you can also add a delay as shown in the example above. Client List When a client is connected to or disconnected from the server, server sends a clients object as an acknowledgement, this object will contain The array of all the clients already in the server; A client id of a client either joining or leaving; and A status indicating if the client is joining or leaving. Client Object: { \"clients\": [\"af221761-d55e-4f8d-a5f3-d7418fe8be92\", \"1a8a73df-4abb-46fd-93dd-19a96e614834\"], \"client\": \"1a8a73df-4abb-46fd-93dd-19a96e614834\", \"status\": \"joining\" } Note The client object is broadcasted, meaning all the connected clients will receive the clients object any time a client joins or leaves the server.","title":"Mocking Websockets"},{"location":"mocking-websockets/#mocking-websockets","text":"Camouflage supports mocking for websockets via native WebSockets API. Note that at this time, custom websockets implementations such as via Socket.io are not supported. Note In following instructions ${WS_MOCKS} refers to the location of websockets' mocks directory as specified under config.ws.mocks_dir in config.yml","title":"Mocking Websockets"},{"location":"mocking-websockets/#how-to-mock-websockets","text":"Start by enabling ws protocol in the config file, provide the location of your ${WS_MOCKS} directory and optionally update the port. The folder structure for ${WS_MOCKS} resembles HTTP mocks, where you create a series of folders under ${WS_MOCKS} e.g. ${WS_MOCKS}/hello/world. This will allow you to connect to the websockets server using the url ws://localhost:8082/hello/world Under /hello/world, you would need to provide two mock files, connection.mock (optional) and message.mock . Camouflage uses connection.mock to send you a custom message when you first connect to the server. This is optional, not providing this file would simply log a warning message in the console. Camouflage uses message.mock to respond to all incoming messages. This too can be optional if you don't want the server to return any messages, but not providing this file would log an error message in the console. The mock file, as you'd expect, supports handlebars! So you can generate random numbers, put conditional blocks etc. The format of mock file would be as follows: { \"broadcast\": \"{{now}}\", \"emit\": \"{{randomValue type='UUID'}}\", \"self\": \"{{randomValue}}\", \"delay\": \"{{num_between lower=500 upper=600}}\" } The JSON can have one or more of these three keys: broadcast , emit or self broadcast: Camouflage will broadcast these messages, i.e. The value which {{now}} evaluates to, in the above example, will be sent to all the connected clients, including the client emitting the message. emit: Camouflage will emit these messages, i.e. The value {{randomValue type='UUID'}} evaluates to in above example, will be sent to all the connected clients, except the client emitting the message. self: Camouflage will only send these messages to the client who made the request, i.e. The value {{randomValue}} evaluates to in above example, will be sent only to the client who made the request. Finally, you can also add a delay as shown in the example above.","title":"How to mock websockets?"},{"location":"mocking-websockets/#client-list","text":"When a client is connected to or disconnected from the server, server sends a clients object as an acknowledgement, this object will contain The array of all the clients already in the server; A client id of a client either joining or leaving; and A status indicating if the client is joining or leaving. Client Object: { \"clients\": [\"af221761-d55e-4f8d-a5f3-d7418fe8be92\", \"1a8a73df-4abb-46fd-93dd-19a96e614834\"], \"client\": \"1a8a73df-4abb-46fd-93dd-19a96e614834\", \"status\": \"joining\" } Note The client object is broadcasted, meaning all the connected clients will receive the clients object any time a client joins or leaves the server.","title":"Client List"},{"location":"openAPI-conversion/","text":"OpenAPI Conversion If you have access to the OpenAPI specification for the APIs/Endpoints you want to mock, Camouflage supports the conversion via an external utility, camoswag . Getting started To use camoswag , you would need your OpenAPI specification file in either .json or .yaml format. You don't need to install camoswag locally on your machine, you can simply run the script using npx. Run the command: npx camoswag --spec ./swagger.yaml or npx camoswag --spec ./swagger.json . (Replace file location with your spec file location) If you would like to install camoswag locally, you can do so by running the command: npm i -g camoswag . For conversion use, camoswag --spec ./swagger.yaml This would create a new folder with the name camouflage-${current_timestamp} containing the required folder structure and mock files corresponding to each endpoint defined in your spec file. You can either delete or modify the dummy responses placed in the mockfiles as per your expectations. Once you are satisfied with the modifications, you can move the contents of the folder to your original ${MOCK_DIR} of your running Camouflage server. Note that if your spec file doesn't contain a response defined for a given endpoint, camoswag would put the following default response in the mock file. { \"message\": \"More Configuration Needed\" } Caution camoswag currently supports JSON responses only.","title":"OpenAPI Conversion"},{"location":"openAPI-conversion/#openapi-conversion","text":"If you have access to the OpenAPI specification for the APIs/Endpoints you want to mock, Camouflage supports the conversion via an external utility, camoswag .","title":"OpenAPI Conversion"},{"location":"openAPI-conversion/#getting-started","text":"To use camoswag , you would need your OpenAPI specification file in either .json or .yaml format. You don't need to install camoswag locally on your machine, you can simply run the script using npx. Run the command: npx camoswag --spec ./swagger.yaml or npx camoswag --spec ./swagger.json . (Replace file location with your spec file location) If you would like to install camoswag locally, you can do so by running the command: npm i -g camoswag . For conversion use, camoswag --spec ./swagger.yaml This would create a new folder with the name camouflage-${current_timestamp} containing the required folder structure and mock files corresponding to each endpoint defined in your spec file. You can either delete or modify the dummy responses placed in the mockfiles as per your expectations. Once you are satisfied with the modifications, you can move the contents of the folder to your original ${MOCK_DIR} of your running Camouflage server. Note that if your spec file doesn't contain a response defined for a given endpoint, camoswag would put the following default response in the mock file. { \"message\": \"More Configuration Needed\" } Caution camoswag currently supports JSON responses only.","title":"Getting started"},{"location":"performance-mode/","text":"Performance Mode By default Camouflage starts on a single CPU, by creating one master and one worker process. This is sufficient for a functional test and a small scale perf test (for a test with 60000 RPM without any latency simulation, 95th percentile response time was around 30 - 40 milliseconds). However, if you are on a multi core machine and you'd like Camouflage to utilize more cores, you can do so by updating the cpus parameter in your config.yml as any number less than the available CPUs. e.g. 4 This will tell Camouflage to start 1 master and 4 workers utilizing 4 cores of your CPU. This leads to a better performance. For a HTTP test with 60000 RPM with latency simulation, 95th between 10 - 13 milliseconds. Reports can be found on the Tests page. Camouflage uses NodeJS cluster module to achieve this, which means it also provides a high availability. If you have specified 4 workers, Camouflage will always ensure that 4 workers are running. In any case if one or more of your workers crash, they will be replaced by a new worker.","title":"Performance Mode"},{"location":"performance-mode/#performance-mode","text":"By default Camouflage starts on a single CPU, by creating one master and one worker process. This is sufficient for a functional test and a small scale perf test (for a test with 60000 RPM without any latency simulation, 95th percentile response time was around 30 - 40 milliseconds). However, if you are on a multi core machine and you'd like Camouflage to utilize more cores, you can do so by updating the cpus parameter in your config.yml as any number less than the available CPUs. e.g. 4 This will tell Camouflage to start 1 master and 4 workers utilizing 4 cores of your CPU. This leads to a better performance. For a HTTP test with 60000 RPM with latency simulation, 95th between 10 - 13 milliseconds. Reports can be found on the Tests page. Camouflage uses NodeJS cluster module to achieve this, which means it also provides a high availability. If you have specified 4 workers, Camouflage will always ensure that 4 workers are running. In any case if one or more of your workers crash, they will be replaced by a new worker.","title":"Performance Mode"},{"location":"proxying/","text":"Proxying Camouflage allows you to proxy selective calls to an external system using {{#proxy}}{{/proxy}} handlebar helper. Proxy support uses http-proxy as it's underlying library and most options are supported as is. To create a proxy endpoint, begin by creating folders and mock file for your desired downstream. Example: If you would like Camouflage to proxy a POST request to a downstream endpoint i.e. /calls-proxied/to/this-target , you would create a file in following manner. ${HTTP_MOCKS_DIR}/calls-proxied/to/this-target/POST.mock Content of this mock file will use proxy block helper and specify a configuration as supported by http-proxy : HTTP/1.1 200 OK {{#proxy}} { \"target\": \"http://localhost:9008\", \"ssl\": { \"key\": \"valid-ssl-key.pem\" \"cert\": \"valid-ssl-cert.pem\" }, \"secure\": true } {{/proxy}} For more details on the available options, refer to http-proxy's documentation Note For options requiring fs.readFileSync(\"path\"), you can simply specify the path as string as shown in ssl.key and ssl.cert example above. Camouflage takes care of reading the file from the specified path.","title":"Proxying"},{"location":"proxying/#proxying","text":"Camouflage allows you to proxy selective calls to an external system using {{#proxy}}{{/proxy}} handlebar helper. Proxy support uses http-proxy as it's underlying library and most options are supported as is. To create a proxy endpoint, begin by creating folders and mock file for your desired downstream. Example: If you would like Camouflage to proxy a POST request to a downstream endpoint i.e. /calls-proxied/to/this-target , you would create a file in following manner. ${HTTP_MOCKS_DIR}/calls-proxied/to/this-target/POST.mock Content of this mock file will use proxy block helper and specify a configuration as supported by http-proxy : HTTP/1.1 200 OK {{#proxy}} { \"target\": \"http://localhost:9008\", \"ssl\": { \"key\": \"valid-ssl-key.pem\" \"cert\": \"valid-ssl-cert.pem\" }, \"secure\": true } {{/proxy}} For more details on the available options, refer to http-proxy's documentation Note For options requiring fs.readFileSync(\"path\"), you can simply specify the path as string as shown in ssl.key and ssl.cert example above. Camouflage takes care of reading the file from the specified path.","title":"Proxying"},{"location":"request-matching/","text":"Request Matching There are scenarios when you would need to change your response based on some conditions met by fields on request objects. For example, if the end user passes an Authorization header, you'd want to send a 200 OK response if not you'd want to send a 401 Unauthorized response. To do so you can utilize the power of handlebars again. Simply provide an if else condition and you are good to go. Consider the following example. You expect the user to call the endpoint /hello-world in two ways. 1) By simple making a GET request to /hello-world.; Or 2) By adding a query parameter name in the GET request to /hello-world. i.e. /hello-world?name=John Based on how the user calls the API, you'd want to send a different response. This can be done in following manner: Create a GET.mock file under the directory ${MOCKS_DIR}/hello-world. And paste following content: {{#if request.query.name}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello {{capture from='query' key='name'}}\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{else}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{/if}} Explanation We are going to check if a query parameter with the key 'name' exists in the incoming request. We do so by adding an if condition {{#if request.query.name}} Note if and unless helpers are provided by handlebarjs, which don't have comparison capabilities. These helpers only check if the provided value is truthy or falsy. i.e. you can not do something like this: {{#if something = something}} . For comparisons, you'd need to use is helper. See Handlebars page for example. Rest of the code is self explanatory, where if the condition is true, i.e. incoming request has a query parameter with key name , the greeting field in our response object would be Hello John , else the greeting would be Hello World . Thus if the end user makes a GET request as /hello-world?name=John , he'd get a greeting Hello John . However, if the user calls /hello-world without any name , he'd get a greeting as Hello World Request Matching using headers To perform request matching using headers the, mocks need to follow a slightly different approach. Using capture helper, we need to capture a specific header value which then can be passed to other helpers like is or if . {{#if (capture from='headers' key='Authorization') }} HTTP/1.1 200 OK Content-Type: application/json { \"response\": \"response if auth header is present.\" } {{else}} HTTP/1.1 401 Unauthorized Content-Type: application/json { \"response\": \"response if no auth header present.\" } {{/if}} If you want to validate a given header against a specific value, the mock file would be as shown below: {{#is (capture from='headers' key='Authorization') 'Basic c2h1YmhlbmR1Om1hZGh1a2Fy' }} HTTP/1.1 200 OK Content-Type: application/json { \"response\": \"response if auth header is present.\" } {{else}} HTTP/1.1 401 Unauthorized Content-Type: application/json { \"response\": \"response if no auth header present.\" } {{/is}} The same validation, albeit messy, can be carried out using code helper, as shown below. This needs config.injection.enable to be set to true Code HTTP/1.1 200 OK Content-Type: application/json {{#code}} (()=>{ const authHeader = request.get('Authorization'); if(authHeader){ return { status: 200, headers: { 'Content-Type': 'application/json' }, body: `{ \"response\": \"response if auth header is present.\" }` }; }else{ return { status: 401, headers: { 'Content-Type': 'application/json' }, body: `{ \"response\": \"response if no auth header present.\" }` }; } })(); {{/code}}","title":"Request matching"},{"location":"request-matching/#request-matching","text":"There are scenarios when you would need to change your response based on some conditions met by fields on request objects. For example, if the end user passes an Authorization header, you'd want to send a 200 OK response if not you'd want to send a 401 Unauthorized response. To do so you can utilize the power of handlebars again. Simply provide an if else condition and you are good to go. Consider the following example. You expect the user to call the endpoint /hello-world in two ways. 1) By simple making a GET request to /hello-world.; Or 2) By adding a query parameter name in the GET request to /hello-world. i.e. /hello-world?name=John Based on how the user calls the API, you'd want to send a different response. This can be done in following manner: Create a GET.mock file under the directory ${MOCKS_DIR}/hello-world. And paste following content: {{#if request.query.name}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello {{capture from='query' key='name'}}\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{else}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{/if}}","title":"Request Matching"},{"location":"request-matching/#explanation","text":"We are going to check if a query parameter with the key 'name' exists in the incoming request. We do so by adding an if condition {{#if request.query.name}} Note if and unless helpers are provided by handlebarjs, which don't have comparison capabilities. These helpers only check if the provided value is truthy or falsy. i.e. you can not do something like this: {{#if something = something}} . For comparisons, you'd need to use is helper. See Handlebars page for example. Rest of the code is self explanatory, where if the condition is true, i.e. incoming request has a query parameter with key name , the greeting field in our response object would be Hello John , else the greeting would be Hello World . Thus if the end user makes a GET request as /hello-world?name=John , he'd get a greeting Hello John . However, if the user calls /hello-world without any name , he'd get a greeting as Hello World","title":"Explanation"},{"location":"request-matching/#request-matching-using-headers","text":"To perform request matching using headers the, mocks need to follow a slightly different approach. Using capture helper, we need to capture a specific header value which then can be passed to other helpers like is or if . {{#if (capture from='headers' key='Authorization') }} HTTP/1.1 200 OK Content-Type: application/json { \"response\": \"response if auth header is present.\" } {{else}} HTTP/1.1 401 Unauthorized Content-Type: application/json { \"response\": \"response if no auth header present.\" } {{/if}} If you want to validate a given header against a specific value, the mock file would be as shown below: {{#is (capture from='headers' key='Authorization') 'Basic c2h1YmhlbmR1Om1hZGh1a2Fy' }} HTTP/1.1 200 OK Content-Type: application/json { \"response\": \"response if auth header is present.\" } {{else}} HTTP/1.1 401 Unauthorized Content-Type: application/json { \"response\": \"response if no auth header present.\" } {{/is}} The same validation, albeit messy, can be carried out using code helper, as shown below. This needs config.injection.enable to be set to true Code HTTP/1.1 200 OK Content-Type: application/json {{#code}} (()=>{ const authHeader = request.get('Authorization'); if(authHeader){ return { status: 200, headers: { 'Content-Type': 'application/json' }, body: `{ \"response\": \"response if auth header is present.\" }` }; }else{ return { status: 401, headers: { 'Content-Type': 'application/json' }, body: `{ \"response\": \"response if no auth header present.\" }` }; } })(); {{/code}}","title":"Request Matching using headers"},{"location":"request-model/","text":"Request model Request object made available by Camouflage is simply an instance of express request object for a given incoming request. Following are the properties/objects available on the request object which can be used in request matching or to extract information out of the request. request.baseUrl request.body request.cookies request.method request.originalUrl request.path request.protocol request.query request.body Refer to Express Documentation for more information on each of these properties.","title":"Request model"},{"location":"request-model/#request-model","text":"Request object made available by Camouflage is simply an instance of express request object for a given incoming request. Following are the properties/objects available on the request object which can be used in request matching or to extract information out of the request. request.baseUrl request.body request.cookies request.method request.originalUrl request.path request.protocol request.query request.body Refer to Express Documentation for more information on each of these properties.","title":"Request model"},{"location":"response-delays/","text":"Response Delay Response delays are handled in a similar manner as it was done in mockserver, i.e. you add a Response-Delay header in raw response placed in your .mock file. For example, if you'd like to simulate a delay of 2 seconds for /hello-world endpoint, contents of your .mock file would be as follows: HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json Response-Delay: 2000 { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } Additionally you can also simulate a dynamic delay using the {{num_between}} handlebar as follows Response-Delay: {{num_between lower=500 upper=600}} This would add a random delay of a value between 500 to 600 milliseconds","title":"Response delays"},{"location":"response-delays/#response-delay","text":"Response delays are handled in a similar manner as it was done in mockserver, i.e. you add a Response-Delay header in raw response placed in your .mock file. For example, if you'd like to simulate a delay of 2 seconds for /hello-world endpoint, contents of your .mock file would be as follows: HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json Response-Delay: 2000 { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } Additionally you can also simulate a dynamic delay using the {{num_between}} handlebar as follows Response-Delay: {{num_between lower=500 upper=600}} This would add a random delay of a value between 500 to 600 milliseconds","title":"Response Delay"},{"location":"tests/","text":"Tests Functional Tests Following functional tests include the results for 7 example APIs available with Camouflage Performance Tests Single CPU This performance test was run on a single node process running without any flags on a single CPU. Test configuration: Test tool used was Locust. Locust was run in a distributed manner with 1 master and 4 workers on a 12 core machine. Please note that performance could be further improved by tuning the node js process or running Camouflage in performance mode. Performance mode: 4 CPU This performance test was on 4 node worker processes without any flags on 4 CPUs Test tool used was Locust. Locust was run in a distributed manner with 1 master and 4 workers on a 12 core machine.","title":"Tests"},{"location":"tests/#tests","text":"","title":"Tests"},{"location":"tests/#functional-tests","text":"Following functional tests include the results for 7 example APIs available with Camouflage","title":"Functional Tests"},{"location":"tests/#performance-tests","text":"","title":"Performance Tests"},{"location":"tests/#single-cpu","text":"This performance test was run on a single node process running without any flags on a single CPU. Test configuration: Test tool used was Locust. Locust was run in a distributed manner with 1 master and 4 workers on a 12 core machine. Please note that performance could be further improved by tuning the node js process or running Camouflage in performance mode.","title":"Single CPU"},{"location":"tests/#performance-mode-4-cpu","text":"This performance test was on 4 node worker processes without any flags on 4 CPUs Test tool used was Locust. Locust was run in a distributed manner with 1 master and 4 workers on a 12 core machine.","title":"Performance mode: 4 CPU"},{"location":"using-with-docker/","text":"Camouflage with Docker Camouflage can be used with the docker image available at Docker Hub . Camouflage can be run with docker using the command, docker container run -d --name camouflage -p 8080:8080 shubhendumadhukar/camouflage:${TAG} , where ${TAG} used in docker image refers to the version of camouflage-server npm package. Port Mapping You can map additional ports to access other protocols and endpoints, e.g. default ports are 8080 - For HTTP 8443 - For HTTPS 8081 - For HTTP2 8082 - For Websockets 4312 - For gRPC 5555 - Exposes a /metrics endpoint for prometheus monitoring Each of these ports can be mapped to a host port of your choice Mounting Volumes Since Camouflage provides you a UI, you can create folders, upload a mock file, delete folders in order to change the mocks behavior at runtime without having to rebuild the docker image or copy additional files to the running containers. You can also achieve the same effect by mounting volumes while starting Camouflage. Create an empty directory in your host machine. Run camouflage init in the directory to generate a starter skeleton of a Camouflage project. Carry out necessary modifications, like deleting example files, modifying config, adding certs, etc. Start Camouflage using command: docker run -d -p 8080:8080 -p 5555:5555 -v $(pwd):/app --name camouflage shubhendumadhukar/camouflage if you are on mac or linux docker run -d -p 8080:8080 -p 5555:5555 -v %cd%:/app --name camouflage shubhendumadhukar/camouflage if you are on Windows To make any changes to mocks you can modify files on your host. Or you can use Camouflage UI to make necessary changes, and these changes will be persisted on your host. Docker Compose The fastest way to get started using Docker would be to use the docker-compose.yml file available in Camouflage Github repo. Download the files docker-compose.yml , camouflage_dashboard.json and prometheus.yml to your local environment. Run the command docker-compose up -d to start following entities: Camouflage Camouflage UI Prometheus Grafana Once all containers are up, simply import camouflage_dashboard.json as a Grafana dashboard. Note Change Grafana Password ( Password@123 ) on first login","title":"Camouflage with Docker"},{"location":"using-with-docker/#camouflage-with-docker","text":"Camouflage can be used with the docker image available at Docker Hub . Camouflage can be run with docker using the command, docker container run -d --name camouflage -p 8080:8080 shubhendumadhukar/camouflage:${TAG} , where ${TAG} used in docker image refers to the version of camouflage-server npm package.","title":"Camouflage with Docker"},{"location":"using-with-docker/#port-mapping","text":"You can map additional ports to access other protocols and endpoints, e.g. default ports are 8080 - For HTTP 8443 - For HTTPS 8081 - For HTTP2 8082 - For Websockets 4312 - For gRPC 5555 - Exposes a /metrics endpoint for prometheus monitoring Each of these ports can be mapped to a host port of your choice","title":"Port Mapping"},{"location":"using-with-docker/#mounting-volumes","text":"Since Camouflage provides you a UI, you can create folders, upload a mock file, delete folders in order to change the mocks behavior at runtime without having to rebuild the docker image or copy additional files to the running containers. You can also achieve the same effect by mounting volumes while starting Camouflage. Create an empty directory in your host machine. Run camouflage init in the directory to generate a starter skeleton of a Camouflage project. Carry out necessary modifications, like deleting example files, modifying config, adding certs, etc. Start Camouflage using command: docker run -d -p 8080:8080 -p 5555:5555 -v $(pwd):/app --name camouflage shubhendumadhukar/camouflage if you are on mac or linux docker run -d -p 8080:8080 -p 5555:5555 -v %cd%:/app --name camouflage shubhendumadhukar/camouflage if you are on Windows To make any changes to mocks you can modify files on your host. Or you can use Camouflage UI to make necessary changes, and these changes will be persisted on your host.","title":"Mounting Volumes"},{"location":"using-with-docker/#docker-compose","text":"The fastest way to get started using Docker would be to use the docker-compose.yml file available in Camouflage Github repo. Download the files docker-compose.yml , camouflage_dashboard.json and prometheus.yml to your local environment. Run the command docker-compose up -d to start following entities: Camouflage Camouflage UI Prometheus Grafana Once all containers are up, simply import camouflage_dashboard.json as a Grafana dashboard. Note Change Grafana Password ( Password@123 ) on first login","title":"Docker Compose"},{"location":"using-with-kubernetes/","text":"Camouflage with Kubernetes Camouflage can be also be used with the Kubernetes using the *.yaml files available at GitHub . Note Provided *.yaml files are in no way optimally tuned to be used in production scenarios, and are expected to change in future to have a more robust structure. We welcome all suggestions for improvements. They can however be used in development environments to quickly deploy and scale Camouflage. What is included? Kubernetes deployments include 5 yaml files: camouflage-depl.yaml - Defines Camouflage pod, along with an init pod to setup Camouflage. Change the desired number of replicas and allocated CPU/Memory here camouflage-ui-depl.yaml - Defines Camouflage UI pod. No further configuration needed. camouflage-pvc.yaml - Allows Camouflage to persist mocks/protofiles data even if a pod is killed, also helps share same data accross pods. Change the assigned storage volume and storage class here camouflage-service.yaml - Defines a loadbalancer service to access mocks. Change port mappings here. camouflage-ui-service.yaml - Defines a loadbalancer service to access UI. Change port mappings here. How it works? To deploy and scale, download all five files and store locally or on your dedicated server. Navigate to the directory containing the five files and run the command: kubectl apply -f . This starts n number of pods as specified in replica, alongwith init pods. This sets up Loadbalancer Service. Finally this sets up a PVC, which is to be populated by the init pods. If the mounted volume is empty, init pods will run camouflage init , so that you don't have to. Any changes/deletion/creation of mocks will be persisted, further init pods created during scaling/deleting/restarting will not change the existing data. Port Mapping You can map ports in camouflage-service.yaml to access available protocols and endpoints. Default ports/mappings are: 8080 - For HTTP 8443 - For HTTPS 8081 - For HTTP2 8082 - For Websockets 4312 - For gRPC 5555 - Exposes a /metrics endpoint for prometheus monitoring Default UI port is 3001, which can be changed in camouflage-ui-service.yaml Each of these ports can be mapped to a host port of your choice Using Camouflage on K8s All mocks and endpoints can be access via the loadbalancer service. As well as any changes to mocks, can be made using Camouflage UI available via the additional UI loadbalancer service.","title":"Camouflage with Kubernetes"},{"location":"using-with-kubernetes/#camouflage-with-kubernetes","text":"Camouflage can be also be used with the Kubernetes using the *.yaml files available at GitHub . Note Provided *.yaml files are in no way optimally tuned to be used in production scenarios, and are expected to change in future to have a more robust structure. We welcome all suggestions for improvements. They can however be used in development environments to quickly deploy and scale Camouflage.","title":"Camouflage with Kubernetes"},{"location":"using-with-kubernetes/#what-is-included","text":"Kubernetes deployments include 5 yaml files: camouflage-depl.yaml - Defines Camouflage pod, along with an init pod to setup Camouflage. Change the desired number of replicas and allocated CPU/Memory here camouflage-ui-depl.yaml - Defines Camouflage UI pod. No further configuration needed. camouflage-pvc.yaml - Allows Camouflage to persist mocks/protofiles data even if a pod is killed, also helps share same data accross pods. Change the assigned storage volume and storage class here camouflage-service.yaml - Defines a loadbalancer service to access mocks. Change port mappings here. camouflage-ui-service.yaml - Defines a loadbalancer service to access UI. Change port mappings here.","title":"What is included?"},{"location":"using-with-kubernetes/#how-it-works","text":"To deploy and scale, download all five files and store locally or on your dedicated server. Navigate to the directory containing the five files and run the command: kubectl apply -f . This starts n number of pods as specified in replica, alongwith init pods. This sets up Loadbalancer Service. Finally this sets up a PVC, which is to be populated by the init pods. If the mounted volume is empty, init pods will run camouflage init , so that you don't have to. Any changes/deletion/creation of mocks will be persisted, further init pods created during scaling/deleting/restarting will not change the existing data.","title":"How it works?"},{"location":"using-with-kubernetes/#port-mapping","text":"You can map ports in camouflage-service.yaml to access available protocols and endpoints. Default ports/mappings are: 8080 - For HTTP 8443 - For HTTPS 8081 - For HTTP2 8082 - For Websockets 4312 - For gRPC 5555 - Exposes a /metrics endpoint for prometheus monitoring Default UI port is 3001, which can be changed in camouflage-ui-service.yaml Each of these ports can be mapped to a host port of your choice","title":"Port Mapping"},{"location":"using-with-kubernetes/#using-camouflage-on-k8s","text":"All mocks and endpoints can be access via the loadbalancer service. As well as any changes to mocks, can be made using Camouflage UI available via the additional UI loadbalancer service.","title":"Using Camouflage on K8s"},{"location":"validation/","text":"When testing software using a mock server it's important that your mocks are correct/valid to avoid false assumptions. Contract testing is a grest methodology for ensuring that two separate systems are compatible and can communicate with one other.\u200b What sets this form of testing apart from other approaches that aim to achieve the same thing, is that each system can be tested independently from the other and that the contract is generated by the code itself, meaning the contract is always kept up to date with reality.\u200b OpenApi schema validation Camouflage server support OpenApi schema's for request and response validation. When enabled the configured schema's are loaded in memory and each request and response simply need to adhere to the rules in schema. Configuration Options By default, validation is disabled. To specify any of these optional configurations, modify config.yml in following way. validation: enable: true schemas: - type: OpenApi url: https://raw.githubusercontent.com/OAI/OpenAPI-Specification/main/examples/v3.0/petstore.json Example Now when you have a mock for the supported endpoint /pets requesting it would result in a proper response. HTTP/1.1 200 OK Content-Type: application/json [ { \"id\": 1, \"name\": \"Rabbit\" }, { \"id\": 2, \"name\": \"Dog\" }, { \"id\": 3, \"name\": \"Cat\" }, { \"id\": 4, \"name\": \"Bird\" } ] Request validation Given this schema for /pets we see that the only support parameter is the integer limit { \"openapi\": \"3.0.0\", \"paths\": { \"/pets\": { \"get\": { \"summary\": \"List all pets\", \"operationId\": \"listPets\", \"parameters\": [ { \"name\": \"limit\", \"in\": \"query\", \"description\": \"How many items to return at one time (max 100)\", \"required\": false, \"schema\": { \"type\": \"integer\", \"format\": \"int32\" } } ] ... } } } Called with an unsupported paraemeter like /pets?unsupported=1 will result in the following 400 error. [ { \"path\": \"page\", \"errorCode\": \"type.openapi.requestValidation\", \"message\": \"unknown query parameter 'unsupported'\", \"location\": \"query\" } ] Called with a wrong type like /pets?limit=abc will also result in the following 400 error. [ { \"path\": \"limit\", \"errorCode\": \"type.openapi.requestValidation\", \"message\": \"must be integer\", \"location\": \"query\" } ] Response validation Given this schema for /pets we see that a pet has two required properties id and name . { \"openapi\": \"3.0.0\", \"paths\": { \"/pets\": { \"get\": { \"summary\": \"List all pets\", \"operationId\": \"listPets\", ... \"responses\": { \"200\": { \"description\": \"A paged array of pets\", \"content\": { \"application/json\": { \"schema\": { \"$ref\": \"#/components/schemas/Pets\" } } } }, ... } } \"components\": { \"schemas\": { \"Pet\": { \"type\": \"object\", \"required\": [ \"id\", \"name\" ], \"properties\": { \"id\": { \"type\": \"integer\", \"format\": \"int64\" }, \"name\": { \"type\": \"string\" }, \"tag\": { \"type\": \"string\" } } }, \"Pets\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/components/schemas/Pet\" } }, ... } } } In case previously your backend api did only had a required property id your assumptions in the tests are false. HTTP/1.1 200 OK Content-Type: application/json [ { \"id\": 1, \"name\": \"Rabbit\" }, { \"id\": 2, \"name\": \"Dog\" }, { \"id\": 3, \"name\": \"Cat\" }, { \"id\": 4 } ] Responses with the following mock will be blocked with a 409 response helping you to avoid mistakes. [ { \"path\": \"3\", \"errorCode\": \"required.openapi.responseValidation\", \"message\": \"must have required property 'name'\" } ]","title":"Validation"},{"location":"validation/#openapi-schema-validation","text":"Camouflage server support OpenApi schema's for request and response validation. When enabled the configured schema's are loaded in memory and each request and response simply need to adhere to the rules in schema.","title":"OpenApi schema validation"},{"location":"validation/#configuration-options","text":"By default, validation is disabled. To specify any of these optional configurations, modify config.yml in following way. validation: enable: true schemas: - type: OpenApi url: https://raw.githubusercontent.com/OAI/OpenAPI-Specification/main/examples/v3.0/petstore.json","title":"Configuration Options"},{"location":"validation/#example","text":"Now when you have a mock for the supported endpoint /pets requesting it would result in a proper response. HTTP/1.1 200 OK Content-Type: application/json [ { \"id\": 1, \"name\": \"Rabbit\" }, { \"id\": 2, \"name\": \"Dog\" }, { \"id\": 3, \"name\": \"Cat\" }, { \"id\": 4, \"name\": \"Bird\" } ]","title":"Example"},{"location":"validation/#request-validation","text":"Given this schema for /pets we see that the only support parameter is the integer limit { \"openapi\": \"3.0.0\", \"paths\": { \"/pets\": { \"get\": { \"summary\": \"List all pets\", \"operationId\": \"listPets\", \"parameters\": [ { \"name\": \"limit\", \"in\": \"query\", \"description\": \"How many items to return at one time (max 100)\", \"required\": false, \"schema\": { \"type\": \"integer\", \"format\": \"int32\" } } ] ... } } } Called with an unsupported paraemeter like /pets?unsupported=1 will result in the following 400 error. [ { \"path\": \"page\", \"errorCode\": \"type.openapi.requestValidation\", \"message\": \"unknown query parameter 'unsupported'\", \"location\": \"query\" } ] Called with a wrong type like /pets?limit=abc will also result in the following 400 error. [ { \"path\": \"limit\", \"errorCode\": \"type.openapi.requestValidation\", \"message\": \"must be integer\", \"location\": \"query\" } ]","title":"Request validation"},{"location":"validation/#response-validation","text":"Given this schema for /pets we see that a pet has two required properties id and name . { \"openapi\": \"3.0.0\", \"paths\": { \"/pets\": { \"get\": { \"summary\": \"List all pets\", \"operationId\": \"listPets\", ... \"responses\": { \"200\": { \"description\": \"A paged array of pets\", \"content\": { \"application/json\": { \"schema\": { \"$ref\": \"#/components/schemas/Pets\" } } } }, ... } } \"components\": { \"schemas\": { \"Pet\": { \"type\": \"object\", \"required\": [ \"id\", \"name\" ], \"properties\": { \"id\": { \"type\": \"integer\", \"format\": \"int64\" }, \"name\": { \"type\": \"string\" }, \"tag\": { \"type\": \"string\" } } }, \"Pets\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/components/schemas/Pet\" } }, ... } } } In case previously your backend api did only had a required property id your assumptions in the tests are false. HTTP/1.1 200 OK Content-Type: application/json [ { \"id\": 1, \"name\": \"Rabbit\" }, { \"id\": 2, \"name\": \"Dog\" }, { \"id\": 3, \"name\": \"Cat\" }, { \"id\": 4 } ] Responses with the following mock will be blocked with a 409 response helping you to avoid mistakes. [ { \"path\": \"3\", \"errorCode\": \"required.openapi.responseValidation\", \"message\": \"must have required property 'name'\" } ]","title":"Response validation"}]}
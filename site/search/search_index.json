{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Camouflage HTTP/gRPC Mocking tool What is Camouflage? Camouflage is a service virtualization tool inspired by namshi/mockserver . As the original description says, the mocking/service virtualization works on a file based structure where you simply organize your mocked HTTP responses in a bunch of mock files and it will serve them like they were coming from a real API; in this way you can write your frontends without caring too much whether your backend is really ready or not. Why did we create Camouflage if a similar tool already exists? Camouflage simply borrows the idea from the original and though it does use some of the same logic and functions, majority of the code has been written from scratch implementing a plethora of amazing new features. The underlying codebase has been re-written using typescript providing a structured, strongly typed, modular codebase. Some features from the original tool might be missing, or have been implemented differently. (import and eval have not been ported to Camouflage) Camouflage introduces handlebars, which allows you to generate dynamic (more real) responses. Using handlebars, you can generate random numbers, strings, alphanumeric strings, UUIDs and random dates. You can also extract information from request queries, path, body or headers and use them in your response. You can use handlebars to carry out request matching for you. For example, return one response if a query param exists, return another if it doesn't. Camouflage supports multiple protocols, i.e. HTTP, HTTPs, HTTP2, gRPC and Websockets(Beta) Camouflage provides inbuilt support for creating backups and restoring from backups in case something goes wrong. Camouflage provides support for monitoring. Head on over to the Getting Started page and set up your first Camouflage project.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#what-is-camouflage","text":"Camouflage is a service virtualization tool inspired by namshi/mockserver . As the original description says, the mocking/service virtualization works on a file based structure where you simply organize your mocked HTTP responses in a bunch of mock files and it will serve them like they were coming from a real API; in this way you can write your frontends without caring too much whether your backend is really ready or not.","title":"What is Camouflage?"},{"location":"#why-did-we-create-camouflage-if-a-similar-tool-already-exists","text":"Camouflage simply borrows the idea from the original and though it does use some of the same logic and functions, majority of the code has been written from scratch implementing a plethora of amazing new features. The underlying codebase has been re-written using typescript providing a structured, strongly typed, modular codebase. Some features from the original tool might be missing, or have been implemented differently. (import and eval have not been ported to Camouflage) Camouflage introduces handlebars, which allows you to generate dynamic (more real) responses. Using handlebars, you can generate random numbers, strings, alphanumeric strings, UUIDs and random dates. You can also extract information from request queries, path, body or headers and use them in your response. You can use handlebars to carry out request matching for you. For example, return one response if a query param exists, return another if it doesn't. Camouflage supports multiple protocols, i.e. HTTP, HTTPs, HTTP2, gRPC and Websockets(Beta) Camouflage provides inbuilt support for creating backups and restoring from backups in case something goes wrong. Camouflage provides support for monitoring. Head on over to the Getting Started page and set up your first Camouflage project.","title":"Why did we create Camouflage if a similar tool already exists?"},{"location":"available-monitoring/","text":"Monitoring Monitoring might not be of paramount importance when you are running unit tests or functional automation tests, but if you plan to use Camouflage for performance testing purposes, you would definitely need some monitoring in place. Thanks to swagger-stats , Camouflage provides you two options. You can use the inbuilt UI provided by swagger-stats by navigating to http://localhost:8080/monitoring, which will lead you to following dashboard updating itself in real time Note If you are running more than one worker, above UI would not provide you aggregated metrics. Data displayed will be worker specific data and at this point, we don't have a control on which worker's data will be displayed. Every time UI refreshes, the displayed data might belong to any of the running workers. To provide the aggregated metrics, Camouflage runs a separate monitoring server, which runs by default on port 5555. The URL http://localhost:5555/metrics acts as a scraping endpoint for your Prometheus server. Store this data in Prometheus and then use Grafana to generate your own visualizations. You can install a Prometheus DB and configure it to scrape from /metrics endpoint, and use that data to create charts for monitoring your application. Sample Prometheus yml global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: \"camouflage\" static_configs: - targets: [\"localhost:5555\"] Note Update the target with your IP and port if running remotely or if you have specified a different port while starting Camouflage","title":"Monitoring"},{"location":"available-monitoring/#monitoring","text":"Monitoring might not be of paramount importance when you are running unit tests or functional automation tests, but if you plan to use Camouflage for performance testing purposes, you would definitely need some monitoring in place. Thanks to swagger-stats , Camouflage provides you two options. You can use the inbuilt UI provided by swagger-stats by navigating to http://localhost:8080/monitoring, which will lead you to following dashboard updating itself in real time Note If you are running more than one worker, above UI would not provide you aggregated metrics. Data displayed will be worker specific data and at this point, we don't have a control on which worker's data will be displayed. Every time UI refreshes, the displayed data might belong to any of the running workers. To provide the aggregated metrics, Camouflage runs a separate monitoring server, which runs by default on port 5555. The URL http://localhost:5555/metrics acts as a scraping endpoint for your Prometheus server. Store this data in Prometheus and then use Grafana to generate your own visualizations. You can install a Prometheus DB and configure it to scrape from /metrics endpoint, and use that data to create charts for monitoring your application. Sample Prometheus yml global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: \"camouflage\" static_configs: - targets: [\"localhost:5555\"] Note Update the target with your IP and port if running remotely or if you have specified a different port while starting Camouflage","title":"Monitoring"},{"location":"back-up-and-restore/","text":"Backup and Restore How does Camouflage Restore work? Camouflage has an inbuilt backup and restore mechanism to keep your mocks safe. To enable or disable backups, update backup.enable property in your config file. To define the schedule for backup, update backup.cron property with a valid cron schedule (Refer Crontab.guru , if you are not familiar with cron schedules ) In order to restore your previously backed up data, all you need is your config.yml file. Run following command in your working directory. camouflage restore --config config.yml What to do if you don't have a config.yml? Run init command first and then restore. camouflage init camouflage restore --config config.yml Camouflage backs up Http mocks directory , key and certificates and gRPC mocks and protos from your project.","title":"Backup and Restore"},{"location":"back-up-and-restore/#backup-and-restore","text":"","title":"Backup and Restore"},{"location":"back-up-and-restore/#how-does-camouflage-restore-work","text":"Camouflage has an inbuilt backup and restore mechanism to keep your mocks safe. To enable or disable backups, update backup.enable property in your config file. To define the schedule for backup, update backup.cron property with a valid cron schedule (Refer Crontab.guru , if you are not familiar with cron schedules ) In order to restore your previously backed up data, all you need is your config.yml file. Run following command in your working directory. camouflage restore --config config.yml What to do if you don't have a config.yml? Run init command first and then restore. camouflage init camouflage restore --config config.yml Camouflage backs up Http mocks directory , key and certificates and gRPC mocks and protos from your project.","title":"How does Camouflage Restore work?"},{"location":"camouflage-ui/","text":"Camouflage UI Camouflage also provide a file explorer UI allowing you to work with your mocks. UI is powered by OpusCapita/filemanager , which provides abilities to perform following actions on the available mocks: Upload mock files Download mock files Rename a mock folder to change stubbed API endpoint Update cert and key Download logs Download config yaml Screenshots:","title":"Camouflage UI"},{"location":"camouflage-ui/#camouflage-ui","text":"Camouflage also provide a file explorer UI allowing you to work with your mocks. UI is powered by OpusCapita/filemanager , which provides abilities to perform following actions on the available mocks: Upload mock files Download mock files Rename a mock folder to change stubbed API endpoint Update cert and key Download logs Download config yaml Screenshots:","title":"Camouflage UI"},{"location":"contributing/","text":"Contributing Folder Structure . \u2514\u2500\u2500 bin \u2502 \u2514\u2500\u2500 camouflage.js \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 BackupScheduler \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 handlebar \u2502 \u2502 \u251c\u2500\u2500 handleBarDefinition.ts \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 logger \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 parser \u2502 \u2502 \u251c\u2500\u2500 GrpcParser.ts \u2502 \u2502 \u2514\u2500\u2500 HttpParser.ts \u2502 \u251c\u2500\u2500 protocols \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 routes \u2502 \u2502 \u251c\u2500\u2500 CamouflageController.ts \u2502 \u2502 \u2514\u2500\u2500 GlobalController.ts \u2502 \u2514\u2500\u2500 index.ts \u2514\u2500\u2500 ... Note Following section only tries to explain the tasks carried out by each module. Actual code level documentation is provided inline with each file for easier access. bin/camouflage.js This is the starting point of the application, which carries out following tasks: Takes in input from terminal/command line and config file. Defines actions for management modules such as camouflage init , camouflage restore and camouflage -h . Creates a cluster of master and worker processes. Decides if the passed arguments are valid and passes them on to the main app, else terminates the appliation with necessary error messages. src/index.ts Once application passes the first stage of checks, it will reach this file, which begins the actual mock server's tasks, namely: Define middlewares which are, express body parser, swagger stats, winston logger for express. Define static resource for two UIs. First, the documentation site hosted at root (/) location and second, file explorer UI hosted at /ui location. Override default values of required parameters. Register handlebars, management controllers and global generic controllers. Export start function to be used by bin/camouflage.js and express app object to be used by functional tests. src/BackupScheduler/index.ts This module simply creates a cron job which in turn copies mocks directories, certs directory and config file to the users' home directory as a backup procedure. The backup directory then can be used to restore the files to current working directory or a new project altogether. User can disable the backup feature if required via config file and can also control how often backups should be created by specifying a cron schedule src/handlebar/handleBarDefinition.ts This modules define the behavior of custom handlebars made available by Camouflage, such as random value helper, now helper, request helper and num between helpers to help users to prepare a response that mimics the real world response. src/handlebar/index.ts A master module for handlebar, simply to register all the helpers in one place. Alternative would be to register helpers in index.ts which is not ideal. src/logger/index.ts Module to define a logger according to the log level defined by config file, to be used throughout the application. src/parser/GrpcParser.ts GrpcParser is responsible for definition of generic functions which will respond to all calls from a gRPC client be it unary, bidi or one sided streams. These functions carry out following tasks: Determine the location appropriate mock files based on the handler specified by the incoming requests. Parse the contents of the mock files Replace templates with their values Add delays Create chunks in case of streams And finally send back the response. src/parser/HttpParser.ts HttpParser is responsible for definition of generic function to be used by GlobalController module. These functions carry out following tasks: Determine the location appropriate mock files based on the request URL path and method. Parse the contents of the mock files Replace templates with their values Add delays Add headers Add status codes Add response body And finally send back the response. src/protocols/index.ts This module creates servers with their listeners for http, https, http2 and gRPC protocols as specified by enabled properties for each protocols in config file. src/routes/CamouflageController.ts Camouflage controller is responsible for definition of endpoints useful for management modules. Available endpoints are: GET /mocks - Lists the available http and grpc mocks. Will be deprecated as the file explorer UI takes care of this internally, rendering this endpoint useless. DELETE /mocks - Deletes a mock with the specified path and method. Will be deprecated as the file explorer UI takes care of this internally, rendering this endpoint useless. GET /restart - Kills all the running workers which then automatically get replaced by their replacements since Camouflage follows 'restart unless explicitly stopped' policy for it's worker management. No UI component for this but will be developed soon. GET /ping - Shows the health and runtime of running worker src/routes/GlobalController.ts Global controller registers generic routes defined by (*) which will respond to all HTTP calls from a client unless explicitly handled by other modules from Camouflage. Uses getMatchedDir and getResponse function to locate appropriate mock file for an incoming HTTP/HTTPs/HTTP2 request and respond with the contents of the mockfile.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#folder-structure","text":". \u2514\u2500\u2500 bin \u2502 \u2514\u2500\u2500 camouflage.js \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 BackupScheduler \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 handlebar \u2502 \u2502 \u251c\u2500\u2500 handleBarDefinition.ts \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 logger \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 parser \u2502 \u2502 \u251c\u2500\u2500 GrpcParser.ts \u2502 \u2502 \u2514\u2500\u2500 HttpParser.ts \u2502 \u251c\u2500\u2500 protocols \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 routes \u2502 \u2502 \u251c\u2500\u2500 CamouflageController.ts \u2502 \u2502 \u2514\u2500\u2500 GlobalController.ts \u2502 \u2514\u2500\u2500 index.ts \u2514\u2500\u2500 ... Note Following section only tries to explain the tasks carried out by each module. Actual code level documentation is provided inline with each file for easier access.","title":"Folder Structure"},{"location":"contributing/#bincamouflagejs","text":"This is the starting point of the application, which carries out following tasks: Takes in input from terminal/command line and config file. Defines actions for management modules such as camouflage init , camouflage restore and camouflage -h . Creates a cluster of master and worker processes. Decides if the passed arguments are valid and passes them on to the main app, else terminates the appliation with necessary error messages.","title":"bin/camouflage.js"},{"location":"contributing/#srcindexts","text":"Once application passes the first stage of checks, it will reach this file, which begins the actual mock server's tasks, namely: Define middlewares which are, express body parser, swagger stats, winston logger for express. Define static resource for two UIs. First, the documentation site hosted at root (/) location and second, file explorer UI hosted at /ui location. Override default values of required parameters. Register handlebars, management controllers and global generic controllers. Export start function to be used by bin/camouflage.js and express app object to be used by functional tests.","title":"src/index.ts"},{"location":"contributing/#srcbackupschedulerindexts","text":"This module simply creates a cron job which in turn copies mocks directories, certs directory and config file to the users' home directory as a backup procedure. The backup directory then can be used to restore the files to current working directory or a new project altogether. User can disable the backup feature if required via config file and can also control how often backups should be created by specifying a cron schedule","title":"src/BackupScheduler/index.ts"},{"location":"contributing/#srchandlebarhandlebardefinitionts","text":"This modules define the behavior of custom handlebars made available by Camouflage, such as random value helper, now helper, request helper and num between helpers to help users to prepare a response that mimics the real world response.","title":"src/handlebar/handleBarDefinition.ts"},{"location":"contributing/#srchandlebarindexts","text":"A master module for handlebar, simply to register all the helpers in one place. Alternative would be to register helpers in index.ts which is not ideal.","title":"src/handlebar/index.ts"},{"location":"contributing/#srcloggerindexts","text":"Module to define a logger according to the log level defined by config file, to be used throughout the application.","title":"src/logger/index.ts"},{"location":"contributing/#srcparsergrpcparserts","text":"GrpcParser is responsible for definition of generic functions which will respond to all calls from a gRPC client be it unary, bidi or one sided streams. These functions carry out following tasks: Determine the location appropriate mock files based on the handler specified by the incoming requests. Parse the contents of the mock files Replace templates with their values Add delays Create chunks in case of streams And finally send back the response.","title":"src/parser/GrpcParser.ts"},{"location":"contributing/#srcparserhttpparserts","text":"HttpParser is responsible for definition of generic function to be used by GlobalController module. These functions carry out following tasks: Determine the location appropriate mock files based on the request URL path and method. Parse the contents of the mock files Replace templates with their values Add delays Add headers Add status codes Add response body And finally send back the response.","title":"src/parser/HttpParser.ts"},{"location":"contributing/#srcprotocolsindexts","text":"This module creates servers with their listeners for http, https, http2 and gRPC protocols as specified by enabled properties for each protocols in config file.","title":"src/protocols/index.ts"},{"location":"contributing/#srcroutescamouflagecontrollerts","text":"Camouflage controller is responsible for definition of endpoints useful for management modules. Available endpoints are: GET /mocks - Lists the available http and grpc mocks. Will be deprecated as the file explorer UI takes care of this internally, rendering this endpoint useless. DELETE /mocks - Deletes a mock with the specified path and method. Will be deprecated as the file explorer UI takes care of this internally, rendering this endpoint useless. GET /restart - Kills all the running workers which then automatically get replaced by their replacements since Camouflage follows 'restart unless explicitly stopped' policy for it's worker management. No UI component for this but will be developed soon. GET /ping - Shows the health and runtime of running worker","title":"src/routes/CamouflageController.ts"},{"location":"contributing/#srcroutesglobalcontrollerts","text":"Global controller registers generic routes defined by (*) which will respond to all HTTP calls from a client unless explicitly handled by other modules from Camouflage. Uses getMatchedDir and getResponse function to locate appropriate mock file for an incoming HTTP/HTTPs/HTTP2 request and respond with the contents of the mockfile.","title":"src/routes/GlobalController.ts"},{"location":"folder-structure/","text":"Folder Structure The way you organize your directories inside the ${MOCKS_DIR}, determine how your endpoints will be available. Following examples will help you understand the folder structure you need to maintain. Basic GET Request to /hello-world Create a directory ${MOCKS_DIR}/hello-world Create a GET.mock file inside it with your required raw html response POST Request to /users Create a directory ${MOCKS_DIR}/users Create a POST.mock file inside it with your required raw html response GET Request to /users/:userId Create a directory ${MOCKS_DIR}/users/__ (double underscore) Create a GET.mock file inside it with your required raw html response Similarily you can create PUT.mock, DELETE.mock etc in your intended path. For wildcard, use directory name as __ (double underscore) Note Unlike original mockserver, request matching criteria, are taken care of inside the .mock files instead of naming the files in a certain way. We intend to keep the file names simple and in the format ${HTTP_METHOD}.mock Caution Protocols http, https and http2, share the same mocks directory and folder structure, however folder structure and mocks directory for gRPC and websockets mocks is different. Please refer to the section Mocking gRPC if you are planning to create gRPC mocks. What data to put in .mock files The data you want to put can be easily fetched using a curl command with -i -X flags in following manner. Example: curl -i -X GET https://jsonplaceholder.typicode.com/users/1 > GET.mock Running this command, gives you a GET.mock file with following content. Modify it according to your requirement and place it in the location ${MOCKS_DIR}/users/__, and you have successfully mocked jsonplaceholder API. HTTP/1.1 200 OK date: Sat, 17 Apr 2021 05:21:51 GMT content-type: application/json; charset=utf-8 content-length: 509 set-cookie: __cfduid=ddf6b687a745fea6ab343400b5dfe9f141618636911; expires=Mon, 17-May-21 05:21:51 GMT; path=/; domain=.typicode.com; HttpOnly; SameSite=Lax x-powered-by: Express x-ratelimit-limit: 1000 x-ratelimit-remaining: 998 x-ratelimit-reset: 1612952731 vary: Origin, Accept-Encoding access-control-allow-credentials: true cache-control: max-age=43200 pragma: no-cache expires: -1 x-content-type-options: nosniff etag: W/\"1fd-+2Y3G3w049iSZtw5t1mzSnunngE\" via: 1.1 vegur cf-cache-status: HIT age: 14578 accept-ranges: bytes cf-request-id: 097fe04d2c000019d97db7d000000001 expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\" report-to: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report?s=%2FkpNonG0wnuykR5xxlGXKBUxm5DN%2BI1PpQ0ytmiw931XaIVBNqZMJLEr0%2F3kDTrOhbX%2FCCPZtI4iuU3V%2F07wO5uwqov0d4c12%2Fcdpiz7TIFqzGkr7DwUrzt40CLH\"}],\"max_age\":604800,\"group\":\"cf-nel\"} nel: {\"max_age\":604800,\"report_to\":\"cf-nel\"} server: cloudflare cf-ray: 6413365b7e9919d9-SIN alt-svc: h3-27=\":443\"; ma=86400, h3-28=\":443\"; ma=86400, h3-29=\":443\"; ma=86400 { \"id\": 1, \"name\": \"Leanne Graham\", \"username\": \"Bret\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"Romaguera-Crona\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } Another, easier, approach to create mocks is by installing the REST Client VS Code Extension and using it to fetch the required data for mocks. Launch VS Code and install \"REST Client\" Extension by Huachao Mao or simply open the link above. Create a .http file in your project to document your actual http endpoints and make the requests. Visit REST Client github repository for more details on usage","title":"Folder Structure"},{"location":"folder-structure/#folder-structure","text":"The way you organize your directories inside the ${MOCKS_DIR}, determine how your endpoints will be available. Following examples will help you understand the folder structure you need to maintain.","title":"Folder Structure"},{"location":"folder-structure/#basic-get-request-to-hello-world","text":"Create a directory ${MOCKS_DIR}/hello-world Create a GET.mock file inside it with your required raw html response","title":"Basic GET Request to /hello-world"},{"location":"folder-structure/#post-request-to-users","text":"Create a directory ${MOCKS_DIR}/users Create a POST.mock file inside it with your required raw html response","title":"POST Request to /users"},{"location":"folder-structure/#get-request-to-usersuserid","text":"Create a directory ${MOCKS_DIR}/users/__ (double underscore) Create a GET.mock file inside it with your required raw html response Similarily you can create PUT.mock, DELETE.mock etc in your intended path. For wildcard, use directory name as __ (double underscore) Note Unlike original mockserver, request matching criteria, are taken care of inside the .mock files instead of naming the files in a certain way. We intend to keep the file names simple and in the format ${HTTP_METHOD}.mock Caution Protocols http, https and http2, share the same mocks directory and folder structure, however folder structure and mocks directory for gRPC and websockets mocks is different. Please refer to the section Mocking gRPC if you are planning to create gRPC mocks.","title":"GET Request to /users/:userId"},{"location":"folder-structure/#what-data-to-put-in-mock-files","text":"The data you want to put can be easily fetched using a curl command with -i -X flags in following manner. Example: curl -i -X GET https://jsonplaceholder.typicode.com/users/1 > GET.mock Running this command, gives you a GET.mock file with following content. Modify it according to your requirement and place it in the location ${MOCKS_DIR}/users/__, and you have successfully mocked jsonplaceholder API. HTTP/1.1 200 OK date: Sat, 17 Apr 2021 05:21:51 GMT content-type: application/json; charset=utf-8 content-length: 509 set-cookie: __cfduid=ddf6b687a745fea6ab343400b5dfe9f141618636911; expires=Mon, 17-May-21 05:21:51 GMT; path=/; domain=.typicode.com; HttpOnly; SameSite=Lax x-powered-by: Express x-ratelimit-limit: 1000 x-ratelimit-remaining: 998 x-ratelimit-reset: 1612952731 vary: Origin, Accept-Encoding access-control-allow-credentials: true cache-control: max-age=43200 pragma: no-cache expires: -1 x-content-type-options: nosniff etag: W/\"1fd-+2Y3G3w049iSZtw5t1mzSnunngE\" via: 1.1 vegur cf-cache-status: HIT age: 14578 accept-ranges: bytes cf-request-id: 097fe04d2c000019d97db7d000000001 expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\" report-to: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report?s=%2FkpNonG0wnuykR5xxlGXKBUxm5DN%2BI1PpQ0ytmiw931XaIVBNqZMJLEr0%2F3kDTrOhbX%2FCCPZtI4iuU3V%2F07wO5uwqov0d4c12%2Fcdpiz7TIFqzGkr7DwUrzt40CLH\"}],\"max_age\":604800,\"group\":\"cf-nel\"} nel: {\"max_age\":604800,\"report_to\":\"cf-nel\"} server: cloudflare cf-ray: 6413365b7e9919d9-SIN alt-svc: h3-27=\":443\"; ma=86400, h3-28=\":443\"; ma=86400, h3-29=\":443\"; ma=86400 { \"id\": 1, \"name\": \"Leanne Graham\", \"username\": \"Bret\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"Romaguera-Crona\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } Another, easier, approach to create mocks is by installing the REST Client VS Code Extension and using it to fetch the required data for mocks. Launch VS Code and install \"REST Client\" Extension by Huachao Mao or simply open the link above. Create a .http file in your project to document your actual http endpoints and make the requests. Visit REST Client github repository for more details on usage","title":"What data to put in .mock files"},{"location":"getting-started/","text":"Getting Started Camouflage is an NPM package, therefore to install Camouflage, you'd need to install NodeJS (>v14) first, if you haven't already done so. Install Camouflage: npm install -g camouflage-server Run camouflage --version to validate the installation was successful. Create an empty directory anywhere in your machine and navigate to it in your terminal. Execute command camouflage init . This creates a basic skeleton of the folders you'd need in order to get started. You can modify these folders as per your requirements. Start the Camouflage server by initializing it with a config.yml file: camouflage --config config.yml Configuration Options / Sample Config yml File loglevel: info cpus: 1 monitoring: port: 5555 ssl: cert: \"./certs/server.cert\" key: \"./certs/server.key\" protocols: http: mocks_dir: \"./mocks\" port: 8080 https: enable: false port: 8443 http2: enable: false port: 8081 grpc: enable: false host: localhost port: 4312 mocks_dir: \"./grpc/mocks\" protos_dir: \"./grpc/protos\" backup: enable: true cron: \"0 * * * *\" # Hourly Backup Create your first mock Camouflage follows the same convention as mockserver to create mocks. For example, You start by creating a directory ${MOCKS_DIR}/hello-world Create a file GET.mock under ${MOCKS_DIR}/hello-world Paste following content: HTTP/1.1 200 OK X-Custom-Header: Custom-Value Content-Type: application/json { \"greeting\": \"Hey! It works!\" } Navigate to http://localhost:8080/hello-world Building from source If you'd like to get the latest version of Camouflage, you can build it from the source. Note Building from source might have it's own drawbacks, most important of all is that source is always in beta. There might be some bugs which are still being worked upon. You might want to proceed with that aspect in mind. Clone the repository: git clone https://github.com/fauxauldrich/camouflage.git Install dependencies: npm install Build the project: npm build At this point you can run Camouflage using: node bin/camouflage.js --config ./config.yml However if you'd like to install Camouflage globally, execute: npm pack Install by running command: npm install -g camouflage-server-${version}.tgz or npm install -g camouflage-server-${version}.zip","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Camouflage is an NPM package, therefore to install Camouflage, you'd need to install NodeJS (>v14) first, if you haven't already done so. Install Camouflage: npm install -g camouflage-server Run camouflage --version to validate the installation was successful. Create an empty directory anywhere in your machine and navigate to it in your terminal. Execute command camouflage init . This creates a basic skeleton of the folders you'd need in order to get started. You can modify these folders as per your requirements. Start the Camouflage server by initializing it with a config.yml file: camouflage --config config.yml","title":"Getting Started"},{"location":"getting-started/#configuration-options-sample-config-yml-file","text":"loglevel: info cpus: 1 monitoring: port: 5555 ssl: cert: \"./certs/server.cert\" key: \"./certs/server.key\" protocols: http: mocks_dir: \"./mocks\" port: 8080 https: enable: false port: 8443 http2: enable: false port: 8081 grpc: enable: false host: localhost port: 4312 mocks_dir: \"./grpc/mocks\" protos_dir: \"./grpc/protos\" backup: enable: true cron: \"0 * * * *\" # Hourly Backup","title":"Configuration Options / Sample Config yml File"},{"location":"getting-started/#create-your-first-mock","text":"Camouflage follows the same convention as mockserver to create mocks. For example, You start by creating a directory ${MOCKS_DIR}/hello-world Create a file GET.mock under ${MOCKS_DIR}/hello-world Paste following content: HTTP/1.1 200 OK X-Custom-Header: Custom-Value Content-Type: application/json { \"greeting\": \"Hey! It works!\" } Navigate to http://localhost:8080/hello-world","title":"Create your first mock"},{"location":"getting-started/#building-from-source","text":"If you'd like to get the latest version of Camouflage, you can build it from the source. Note Building from source might have it's own drawbacks, most important of all is that source is always in beta. There might be some bugs which are still being worked upon. You might want to proceed with that aspect in mind. Clone the repository: git clone https://github.com/fauxauldrich/camouflage.git Install dependencies: npm install Build the project: npm build At this point you can run Camouflage using: node bin/camouflage.js --config ./config.yml However if you'd like to install Camouflage globally, execute: npm pack Install by running command: npm install -g camouflage-server-${version}.tgz or npm install -g camouflage-server-${version}.zip","title":"Building from source"},{"location":"handlebars/","text":"Handlebars Handlebars help you add character to your response. Instead of sending a static response or writing some code to generate a dynamic response, you can now simply use handlebars and let Camouflage do the work for you. Note Though Camouflage does not provide any tools to help you create your mocks, there are numerous Handlerbar snippet extensions available in VS Code marketplace which should help speed up your mocks creation process. Custom Helpers randomValue Type: Custom Helper Usage: {{randomValue}} - Simply using randomValue will generate a 16 character alphanumeric string. ex: 9ZeBvHW5viiYuWRa . {{randomValue type='ALPHANUMERIC'}} - You can specify a type as well. Your choices are: 'ALPHANUMERIC', 'ALPHABETIC', 'NUMERIC' and 'UUID'. {{randomValue type='NUMERIC' length=10}} - Don't want a 16 character output? Use length to specify the length. {{randomValue type='ALPHABETIC' uppercase=true}} - Finally, specify uppercase as true to get a, well, uppercase string. now Type: Custom Helper Usage: {{now}} - Simply using now will give you date in format YYYY-MM-DD hh:mm:ss {{now format='MM/DD/YYYY'}} - Format not to your liking? Use any format you'd like as long as it is supported by momentjs. {{now format='epoch'}} - Time since epoch in milliseconds {{now format='unix'}} - Time since epoch in seconds {{now format='MM/DD/YYYY hh:mm:ss' offset='-10 days'}} - Use offset specify the delta for your desired date from current date. Units for specifying offset are Key Shorthand years y quarters q months M weeks w days d hours h minutes m seconds s milliseconds ms capture Type: Custom Helper Usage: {{capture from='query' key='firstName'}} - Pretty self-explanatory, but if say your endpoint looks like /hello-world?firstName=John&lastName=Wick. And your response is {\"message\": \"Hello Wick, John\"}, you can make the response dynamic by formatting your response as { \"message\": \"{{capture from='query' key='lastName'}}, {{capture from='query' key='firstName'}}\" } {{capture from='path' regex='\\/users\\/get\\/(.*)?'}} - For path, you'd need to specify a regex to capture a value. {{capture from='body' using='jsonpath' selector='$.lastName'}} - To capture values from request body, your options are either using='regex' or using='jsonpath'. Selector will change accordingly. num_between Type: Custom Helper Usage: {{num_between lower=500 upper=600}} : Generate a number between two values. Example: you can add this value in your response header with a key Response-Delay, to simulate a latency in your API. Not providing lower/upper value or providing values where lower > upper would set delay to 0, i.e. won't have any effect. Check Response Delays page for a detailed example file Type: Custom Helper Usage: {{file path='/location/of/the/image/or/text/or/any/file'}} : If you want to serve a file as a response, maybe an image, or text file, a pdf document, or any type of supported files, use file helper to do so. An example is shown below: HTTP/1.1 200 OK X-Custom-Header: Any Custom Value Response-Delay: 500 {{file path='./docs/camouflage.png'}} Inbuilt Helpers Note A variety of helpers are made available by Handlebar.js itself and Camouflage team had nothing to do with those, and we don't take credit for it. Following example just showcases how the inbuilt helpers can be used with Camouflage, more details and examples can be found just about anywhere on the internet. As far as inbuilt helpers are concerned, you can use any of them as long as it makes sense to you. Raw HTML Request: POST /users HTTP/1.1 Content-Type: application/json { \"firstName\": \"Robert\", \"lastName\": \"Downey\", \"nicknames\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } Expected Raw HTML Response: HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91\", \"data\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } To create this service in camouflage, create a directory users under your ${MOCKS_DIR}. i.e. ${MOCKS_DIR}/users Create a file POST.mock and add following content to the file HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: {{randomValue type='UUID'}}\", \"data\": [ {{#each request.body.nicknames}} {{#if @last}} { \"nickname\": \"{{this.nickname}}\" } {{else}} { \"nickname\": \"{{this.nickname}}\" }, {{/if}} {{/each}} ] } Explanation We replaced the static UUID f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91 with {{randomValue type='UUID'}} , so that this value updates on each request. We wrapped our JSONObject inside data array with an each helper which iterates over nicknames array from request body. Finally we put an if condition to check if we are at the last element of the array, we shouldn't append a comma at the end of our JSONObject, in order to get a valid JSON. If we are at any other element in the array, we'll add a comma to JSONObject. Available inbuilt helpers are if , unless , each , with , lookup and log . More details are available at Handlebars Documentation","title":"Handlebars"},{"location":"handlebars/#handlebars","text":"Handlebars help you add character to your response. Instead of sending a static response or writing some code to generate a dynamic response, you can now simply use handlebars and let Camouflage do the work for you. Note Though Camouflage does not provide any tools to help you create your mocks, there are numerous Handlerbar snippet extensions available in VS Code marketplace which should help speed up your mocks creation process.","title":"Handlebars"},{"location":"handlebars/#custom-helpers","text":"","title":"Custom Helpers"},{"location":"handlebars/#randomvalue","text":"Type: Custom Helper Usage: {{randomValue}} - Simply using randomValue will generate a 16 character alphanumeric string. ex: 9ZeBvHW5viiYuWRa . {{randomValue type='ALPHANUMERIC'}} - You can specify a type as well. Your choices are: 'ALPHANUMERIC', 'ALPHABETIC', 'NUMERIC' and 'UUID'. {{randomValue type='NUMERIC' length=10}} - Don't want a 16 character output? Use length to specify the length. {{randomValue type='ALPHABETIC' uppercase=true}} - Finally, specify uppercase as true to get a, well, uppercase string.","title":"randomValue"},{"location":"handlebars/#now","text":"Type: Custom Helper Usage: {{now}} - Simply using now will give you date in format YYYY-MM-DD hh:mm:ss {{now format='MM/DD/YYYY'}} - Format not to your liking? Use any format you'd like as long as it is supported by momentjs. {{now format='epoch'}} - Time since epoch in milliseconds {{now format='unix'}} - Time since epoch in seconds {{now format='MM/DD/YYYY hh:mm:ss' offset='-10 days'}} - Use offset specify the delta for your desired date from current date. Units for specifying offset are Key Shorthand years y quarters q months M weeks w days d hours h minutes m seconds s milliseconds ms","title":"now"},{"location":"handlebars/#capture","text":"Type: Custom Helper Usage: {{capture from='query' key='firstName'}} - Pretty self-explanatory, but if say your endpoint looks like /hello-world?firstName=John&lastName=Wick. And your response is {\"message\": \"Hello Wick, John\"}, you can make the response dynamic by formatting your response as { \"message\": \"{{capture from='query' key='lastName'}}, {{capture from='query' key='firstName'}}\" } {{capture from='path' regex='\\/users\\/get\\/(.*)?'}} - For path, you'd need to specify a regex to capture a value. {{capture from='body' using='jsonpath' selector='$.lastName'}} - To capture values from request body, your options are either using='regex' or using='jsonpath'. Selector will change accordingly.","title":"capture"},{"location":"handlebars/#num_between","text":"Type: Custom Helper Usage: {{num_between lower=500 upper=600}} : Generate a number between two values. Example: you can add this value in your response header with a key Response-Delay, to simulate a latency in your API. Not providing lower/upper value or providing values where lower > upper would set delay to 0, i.e. won't have any effect. Check Response Delays page for a detailed example","title":"num_between"},{"location":"handlebars/#file","text":"Type: Custom Helper Usage: {{file path='/location/of/the/image/or/text/or/any/file'}} : If you want to serve a file as a response, maybe an image, or text file, a pdf document, or any type of supported files, use file helper to do so. An example is shown below: HTTP/1.1 200 OK X-Custom-Header: Any Custom Value Response-Delay: 500 {{file path='./docs/camouflage.png'}}","title":"file"},{"location":"handlebars/#inbuilt-helpers","text":"Note A variety of helpers are made available by Handlebar.js itself and Camouflage team had nothing to do with those, and we don't take credit for it. Following example just showcases how the inbuilt helpers can be used with Camouflage, more details and examples can be found just about anywhere on the internet. As far as inbuilt helpers are concerned, you can use any of them as long as it makes sense to you. Raw HTML Request: POST /users HTTP/1.1 Content-Type: application/json { \"firstName\": \"Robert\", \"lastName\": \"Downey\", \"nicknames\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } Expected Raw HTML Response: HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91\", \"data\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } To create this service in camouflage, create a directory users under your ${MOCKS_DIR}. i.e. ${MOCKS_DIR}/users Create a file POST.mock and add following content to the file HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: {{randomValue type='UUID'}}\", \"data\": [ {{#each request.body.nicknames}} {{#if @last}} { \"nickname\": \"{{this.nickname}}\" } {{else}} { \"nickname\": \"{{this.nickname}}\" }, {{/if}} {{/each}} ] } Explanation We replaced the static UUID f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91 with {{randomValue type='UUID'}} , so that this value updates on each request. We wrapped our JSONObject inside data array with an each helper which iterates over nicknames array from request body. Finally we put an if condition to check if we are at the last element of the array, we shouldn't append a comma at the end of our JSONObject, in order to get a valid JSON. If we are at any other element in the array, we'll add a comma to JSONObject. Available inbuilt helpers are if , unless , each , with , lookup and log . More details are available at Handlebars Documentation","title":"Inbuilt Helpers"},{"location":"mocking-gRPC/","text":"Mocking gRPC Camouflage introduces mocking gRPC services. Creation of mocks remains similar to HTTP mocks with some minor changes. For starters, gRPC mocks should not be placed in the same mocks directory as HTTP mocks, instead they should have their own mocks and protos directories. Secondly, the folder structure inside grpc mocks directory will follow the convention ./grpc/mocks/ package_name / service_name / method_name .mock Creating a gRPC Mock - Unary Or Client Side Streaming To create a new grpc mock, you would need the .proto file for your gRPC service. ex. todo.proto Create two new directories ./grpc/mocks and ./grpc/protos (you can name them as you wish) Place your .proto file in ./grpc/protos directory. Now, all we need is a .mock file. But, creating folder structure for gRPC follows a slightly different approach compared to HTTP mocks, and could be little complicated if you are not aware of Protofile syntanx. In any case, you would need following steps. Start by looking for a package name in your .proto file. Next you'd need the service name, and finally the method you need to mock. Create a new folder in ./grpc/mocks directory with the package name. e.g. ./grpc/mocks/todoPackage Create another folder in ./grpc/mocks/todoPackage directory with the service name. e.g. ./grpc/mocks/todoPackage/TodoService Finally create a .mock file in the directory ./grpc/mocks/todoPackage/TodoService with the method name. e.g ./grpc/mocks/todoPackage/TodoService/createTodo.mock Place your expected response in the mock file and you are done. You can use the handlebars as usual in your response!! { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } Creating a gRPC Mock - Server Side Streaming In case you are creating a service with server side streaming, you can place a seperator between each chunk of responses in following manner: { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } ==== { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } ==== { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } Note The seperator Camouflage understands is '====', i.e. 4 equals. Creating a gRPC Mock - Bidi Streaming If you are creating a bidirectional streaming mock, your mock file would contain two different types of data. One, what to send when client is streaming, defined by the key \"data\". Two, an optional key \"end\", in case you want server to send something when client ends the connection. If your requirement is to simply end the stream when client ends the stream, without sending any additional data, you can simply omit the \"end\" key from your mockfile. { \"data\": { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" }, \"end\": { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } } Caution Since BIDI streaming are slightly more complicated to simulate, current implementation of Camouflage only supports ping-pong model of streaming, i.e. client can send multiple requests as a stream and server will respond to each request with one response as part of a stream. Finally when client ends the stream, server will also end the stream. As shown in the example above, server can also send a response just before ending the stream, but this is optional. Adding delays in gRPC You can also add delays in your grpc mock services, by adding a delay key with the value in your mock file. { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } You don't need to modify your proto file to accomodate the additional key, since Camouflage will delete the \"delay\" key from the response before sending it to the client. Caution Since Camouflage gRPC server needs to register the new services everytime you create new mock, you'd need to restart the Camouflage server. Good news is, you can do so easily by making a get request to /restart endpoint. Though the downtime is minimal (less than a second, we do not recommend restarting the server during a performance test.","title":"Mocking gRPC"},{"location":"mocking-gRPC/#mocking-grpc","text":"Camouflage introduces mocking gRPC services. Creation of mocks remains similar to HTTP mocks with some minor changes. For starters, gRPC mocks should not be placed in the same mocks directory as HTTP mocks, instead they should have their own mocks and protos directories. Secondly, the folder structure inside grpc mocks directory will follow the convention ./grpc/mocks/ package_name / service_name / method_name .mock","title":"Mocking gRPC"},{"location":"mocking-gRPC/#creating-a-grpc-mock-unary-or-client-side-streaming","text":"To create a new grpc mock, you would need the .proto file for your gRPC service. ex. todo.proto Create two new directories ./grpc/mocks and ./grpc/protos (you can name them as you wish) Place your .proto file in ./grpc/protos directory. Now, all we need is a .mock file. But, creating folder structure for gRPC follows a slightly different approach compared to HTTP mocks, and could be little complicated if you are not aware of Protofile syntanx. In any case, you would need following steps. Start by looking for a package name in your .proto file. Next you'd need the service name, and finally the method you need to mock. Create a new folder in ./grpc/mocks directory with the package name. e.g. ./grpc/mocks/todoPackage Create another folder in ./grpc/mocks/todoPackage directory with the service name. e.g. ./grpc/mocks/todoPackage/TodoService Finally create a .mock file in the directory ./grpc/mocks/todoPackage/TodoService with the method name. e.g ./grpc/mocks/todoPackage/TodoService/createTodo.mock Place your expected response in the mock file and you are done. You can use the handlebars as usual in your response!! { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" }","title":"Creating a gRPC Mock - Unary Or Client Side Streaming"},{"location":"mocking-gRPC/#creating-a-grpc-mock-server-side-streaming","text":"In case you are creating a service with server side streaming, you can place a seperator between each chunk of responses in following manner: { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } ==== { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } ==== { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } Note The seperator Camouflage understands is '====', i.e. 4 equals.","title":"Creating a gRPC Mock - Server Side Streaming"},{"location":"mocking-gRPC/#creating-a-grpc-mock-bidi-streaming","text":"If you are creating a bidirectional streaming mock, your mock file would contain two different types of data. One, what to send when client is streaming, defined by the key \"data\". Two, an optional key \"end\", in case you want server to send something when client ends the connection. If your requirement is to simply end the stream when client ends the stream, without sending any additional data, you can simply omit the \"end\" key from your mockfile. { \"data\": { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" }, \"end\": { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\" } } Caution Since BIDI streaming are slightly more complicated to simulate, current implementation of Camouflage only supports ping-pong model of streaming, i.e. client can send multiple requests as a stream and server will respond to each request with one response as part of a stream. Finally when client ends the stream, server will also end the stream. As shown in the example above, server can also send a response just before ending the stream, but this is optional.","title":"Creating a gRPC Mock - Bidi Streaming"},{"location":"mocking-gRPC/#adding-delays-in-grpc","text":"You can also add delays in your grpc mock services, by adding a delay key with the value in your mock file. { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{randomValue type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } You don't need to modify your proto file to accomodate the additional key, since Camouflage will delete the \"delay\" key from the response before sending it to the client. Caution Since Camouflage gRPC server needs to register the new services everytime you create new mock, you'd need to restart the Camouflage server. Good news is, you can do so easily by making a get request to /restart endpoint. Though the downtime is minimal (less than a second, we do not recommend restarting the server during a performance test.","title":"Adding delays in gRPC"},{"location":"mocking-websockets/","text":"Mocking Websockets Camouflage supports mocking for websockets via native WebSockets API. Note that at this time, custom websockets implementations such as via Socket.io is not supported. Note In following instructions ${WS_MOCKS} refers to the location of websockets' mocks directory as specified under config.ws.mocks_dir in config.yml How to mock websockets? Start by enabling ws protocol in config file, provide the location of your ${WS_MOCKS} directory and optionally update the port. The folder structure for ${WS_MOCKS} resembles HTTP mocks, where you create a series of folders under ${WS_MOCKS} e.g. ${WS_MOCKS}/hello/world. This will allow you to connect to the websockets server using the url ws://localhost:8082/hello/world Under /hello/world, you would need to provide two mock files, connection.mock (optional) and message.mock . Camouflage uses connection.mock to send you a custom message when you first connect to the server. This is optional, not providing this file would simply log a warning message in Camouflage console. Camouflage uses message.mock to respond to all incoming messages. This too can be optional if you don't want server to return any messages, but not providing this file would log an error message in Camouflage console. The mock file, as you'd expect, supports handlebars! So you can generate random numbers, put conditional blocks etc. The format of mock file would be as follows: { \"broadcast\": \"{{now}}\", \"emit\": \"{{randomValue type='UUID'}}\", \"self\": \"{{randomValue}}\", \"delay\": \"{{num_between lower=500 upper=600}}\" } The JSON can have one or more of these three keys: broadcast , emit or self boardcast: Camouflage will broadcast these messages, i.e. The value {{now}} evaluates to in above example, will be sent to all the connected clients, including the client emitting the message. emit: Camouflage will emit these messages, i.e. The value {{randomValue type='UUID'}} evaluates to in above example, will be sent to all the connected clients, except the client emitting the message. self: Camouflage will only send these messages to the client who made the request, i.e. The value {{randomValue}} evaluates to in above example, will be sent only to the client who made the request. Finally, you can also add a delay as shown in the example above. Client List When a client is connected to or disconnected from the server, server sends a clients object as an acknowledgement, this object will contain The array of all the clients already in the server; A client id of a client either joining or leaving; and A status indicating if the client is joining or leaving. Client Object: { \"clients\": [\"af221761-d55e-4f8d-a5f3-d7418fe8be92\", \"1a8a73df-4abb-46fd-93dd-19a96e614834\"], \"client\": \"1a8a73df-4abb-46fd-93dd-19a96e614834\", \"status\": \"joining\" } Note The client object is broadcasted, meaning all the connected clients will recieve the clients object any time a client joins or leaves the server.","title":"Mocking Websockets"},{"location":"mocking-websockets/#mocking-websockets","text":"Camouflage supports mocking for websockets via native WebSockets API. Note that at this time, custom websockets implementations such as via Socket.io is not supported. Note In following instructions ${WS_MOCKS} refers to the location of websockets' mocks directory as specified under config.ws.mocks_dir in config.yml","title":"Mocking Websockets"},{"location":"mocking-websockets/#how-to-mock-websockets","text":"Start by enabling ws protocol in config file, provide the location of your ${WS_MOCKS} directory and optionally update the port. The folder structure for ${WS_MOCKS} resembles HTTP mocks, where you create a series of folders under ${WS_MOCKS} e.g. ${WS_MOCKS}/hello/world. This will allow you to connect to the websockets server using the url ws://localhost:8082/hello/world Under /hello/world, you would need to provide two mock files, connection.mock (optional) and message.mock . Camouflage uses connection.mock to send you a custom message when you first connect to the server. This is optional, not providing this file would simply log a warning message in Camouflage console. Camouflage uses message.mock to respond to all incoming messages. This too can be optional if you don't want server to return any messages, but not providing this file would log an error message in Camouflage console. The mock file, as you'd expect, supports handlebars! So you can generate random numbers, put conditional blocks etc. The format of mock file would be as follows: { \"broadcast\": \"{{now}}\", \"emit\": \"{{randomValue type='UUID'}}\", \"self\": \"{{randomValue}}\", \"delay\": \"{{num_between lower=500 upper=600}}\" } The JSON can have one or more of these three keys: broadcast , emit or self boardcast: Camouflage will broadcast these messages, i.e. The value {{now}} evaluates to in above example, will be sent to all the connected clients, including the client emitting the message. emit: Camouflage will emit these messages, i.e. The value {{randomValue type='UUID'}} evaluates to in above example, will be sent to all the connected clients, except the client emitting the message. self: Camouflage will only send these messages to the client who made the request, i.e. The value {{randomValue}} evaluates to in above example, will be sent only to the client who made the request. Finally, you can also add a delay as shown in the example above.","title":"How to mock websockets?"},{"location":"mocking-websockets/#client-list","text":"When a client is connected to or disconnected from the server, server sends a clients object as an acknowledgement, this object will contain The array of all the clients already in the server; A client id of a client either joining or leaving; and A status indicating if the client is joining or leaving. Client Object: { \"clients\": [\"af221761-d55e-4f8d-a5f3-d7418fe8be92\", \"1a8a73df-4abb-46fd-93dd-19a96e614834\"], \"client\": \"1a8a73df-4abb-46fd-93dd-19a96e614834\", \"status\": \"joining\" } Note The client object is broadcasted, meaning all the connected clients will recieve the clients object any time a client joins or leaves the server.","title":"Client List"},{"location":"performance-mode/","text":"Performance Mode By default Camouflage starts on a single CPU, by creating one master and one worker process. This is sufficient for a functional test and a small scale perf test (for a test with 60000 RPM without any latency simulation, 95th percentile response time was around 30 - 40 milliseconds). However, if you are on a multi core machine and you'd like Camouflage to utilize more cores, you can do so by updating the cpus parameter in your config.yml as any number less than the available CPUs. e.g. 4 This will tell Camouflage to start 1 master and 4 workers utilizing 4 cores of your CPU. This leads to a better performance. For a HTTP test with 60000 RPM with latency simulation, 95th between 10 - 13 millseconds. Reports can be found on the Tests page. Camouflage uses NodeJS cluster module to achieve this, which means it also provides a high availability. If you have specfied 4 workers, Camouflage will always ensure that 4 workers are running. In any case if one or more of your workers crash, they will be replaced by a new worker.","title":"Performance Mode"},{"location":"performance-mode/#performance-mode","text":"By default Camouflage starts on a single CPU, by creating one master and one worker process. This is sufficient for a functional test and a small scale perf test (for a test with 60000 RPM without any latency simulation, 95th percentile response time was around 30 - 40 milliseconds). However, if you are on a multi core machine and you'd like Camouflage to utilize more cores, you can do so by updating the cpus parameter in your config.yml as any number less than the available CPUs. e.g. 4 This will tell Camouflage to start 1 master and 4 workers utilizing 4 cores of your CPU. This leads to a better performance. For a HTTP test with 60000 RPM with latency simulation, 95th between 10 - 13 millseconds. Reports can be found on the Tests page. Camouflage uses NodeJS cluster module to achieve this, which means it also provides a high availability. If you have specfied 4 workers, Camouflage will always ensure that 4 workers are running. In any case if one or more of your workers crash, they will be replaced by a new worker.","title":"Performance Mode"},{"location":"request-matching/","text":"Request Matching There are scenarios when you would need to change your response based on some conditions met by fields on request objects. For example, if the end user passes an Authorization header, you'd want to send a 200 OK response if not you'd want to send a 401 Unauthorized resposne. To do so you can utilize the power of handlebars again. Simply provide an if else condition and you are good to go. Consider following example. You expect the user to call the endpoint /hello-world in two ways. 1) By simple making a GET request to /hello-world.; Or 2) By adding a query parameter name in the GET request to /hello-world. i.e. /hello-world?name=John Based on how the user calls the API, you'd want to send a different response. This can be done in following manner: Create GET.mock file under the directory ${MOCKS_DIR}/hello-world. And paste following content: {{#if request.query.name}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello {{capture from='query' key='name'}}\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{else}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{/if}} Explanation We are going to check if a query parameter with the key 'name' exists in the incoming request. We do so by adding an if condition {{#if request.query.name}} You can also check if that parameter equals a certain value {{#if request.query.name='John'}} Rest of the code is self explanatory, where if the condition is true, i.e. incoming request has a query parameter with key name , the greeting field in our response object would be Hello John , else the greeting would be Hello World . Thus if the end user makes a GET request as /hello-world?name=John , he'd get a greeting Hello John . However, if the user calls /hello-world without any name , he'd get a greeting as Hello World","title":"Request matching"},{"location":"request-matching/#request-matching","text":"There are scenarios when you would need to change your response based on some conditions met by fields on request objects. For example, if the end user passes an Authorization header, you'd want to send a 200 OK response if not you'd want to send a 401 Unauthorized resposne. To do so you can utilize the power of handlebars again. Simply provide an if else condition and you are good to go. Consider following example. You expect the user to call the endpoint /hello-world in two ways. 1) By simple making a GET request to /hello-world.; Or 2) By adding a query parameter name in the GET request to /hello-world. i.e. /hello-world?name=John Based on how the user calls the API, you'd want to send a different response. This can be done in following manner: Create GET.mock file under the directory ${MOCKS_DIR}/hello-world. And paste following content: {{#if request.query.name}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello {{capture from='query' key='name'}}\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{else}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{/if}}","title":"Request Matching"},{"location":"request-matching/#explanation","text":"We are going to check if a query parameter with the key 'name' exists in the incoming request. We do so by adding an if condition {{#if request.query.name}} You can also check if that parameter equals a certain value {{#if request.query.name='John'}} Rest of the code is self explanatory, where if the condition is true, i.e. incoming request has a query parameter with key name , the greeting field in our response object would be Hello John , else the greeting would be Hello World . Thus if the end user makes a GET request as /hello-world?name=John , he'd get a greeting Hello John . However, if the user calls /hello-world without any name , he'd get a greeting as Hello World","title":"Explanation"},{"location":"request-model/","text":"Request model Request object made available by camouflage is simply an instance of express request object for a given incoming request. Following are the properties/objects available on the request object which can be used in request matching or to extract information out of the request. request.baseUrl request.body request.cookies request.method request.originalUrl request.path request.protocol request.query request.headers request.body Refer to Express Documentation for more information on each of these properties.","title":"Request model"},{"location":"request-model/#request-model","text":"Request object made available by camouflage is simply an instance of express request object for a given incoming request. Following are the properties/objects available on the request object which can be used in request matching or to extract information out of the request. request.baseUrl request.body request.cookies request.method request.originalUrl request.path request.protocol request.query request.headers request.body Refer to Express Documentation for more information on each of these properties.","title":"Request model"},{"location":"response-delays/","text":"Response Delay Response delays are handled in a similar manner as it was done in mockserver, i.e. you add a Response-Delay header in raw response placed in your .mock file. For example, if you'd like to simulate a delay of 2 seconds for /hello-world endpoint, contents of your .mock file would be as follows: HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json Response-Delay: 2000 { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } Additionally you can also simulate a dynamic delay using the {{num_between}} handlebar as follows Response-Delay: {{num_between lower=500 upper=600}} This would add a random delay of a value between 500 to 600 milliseconds","title":"Response delays"},{"location":"response-delays/#response-delay","text":"Response delays are handled in a similar manner as it was done in mockserver, i.e. you add a Response-Delay header in raw response placed in your .mock file. For example, if you'd like to simulate a delay of 2 seconds for /hello-world endpoint, contents of your .mock file would be as follows: HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json Response-Delay: 2000 { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } Additionally you can also simulate a dynamic delay using the {{num_between}} handlebar as follows Response-Delay: {{num_between lower=500 upper=600}} This would add a random delay of a value between 500 to 600 milliseconds","title":"Response Delay"},{"location":"tests/","text":"Tests Functional Tests Following functional tests include the results for 7 example APIs available with Camouflage Performance Tests Single CPU This performance test was run on a single node process running without any flags on a single CPU. Test configuration: Test tool used was Locust. Locust was run in a distributed manner with 1 master and 4 workers on a 12 core machine. Please note that performance could be further improved by tuning the node js process or running Camouflage in performance mode. Performance mode: 4 CPU This performance test was on 4 node worker processes without any flags on 4 CPUs Test tool used was Locust. Locust was run in a distributed manner with 1 master and 4 workers on a 12 core machine.","title":"Tests"},{"location":"tests/#tests","text":"","title":"Tests"},{"location":"tests/#functional-tests","text":"Following functional tests include the results for 7 example APIs available with Camouflage","title":"Functional Tests"},{"location":"tests/#performance-tests","text":"","title":"Performance Tests"},{"location":"tests/#single-cpu","text":"This performance test was run on a single node process running without any flags on a single CPU. Test configuration: Test tool used was Locust. Locust was run in a distributed manner with 1 master and 4 workers on a 12 core machine. Please note that performance could be further improved by tuning the node js process or running Camouflage in performance mode.","title":"Single CPU"},{"location":"tests/#performance-mode-4-cpu","text":"This performance test was on 4 node worker processes without any flags on 4 CPUs Test tool used was Locust. Locust was run in a distributed manner with 1 master and 4 workers on a 12 core machine.","title":"Performance mode: 4 CPU"}]}